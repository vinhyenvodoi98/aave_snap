{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://snap/../node_modules/fast-xml-parser/src/fxp.js","webpack://snap/../node_modules/fast-xml-parser/src/util.js","webpack://snap/../node_modules/fast-xml-parser/src/validator.js","webpack://snap/../node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js","webpack://snap/../node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js","webpack://snap/../node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js","webpack://snap/../node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js","webpack://snap/../node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js","webpack://snap/../node_modules/fast-xml-parser/src/xmlparser/XMLParser.js","webpack://snap/../node_modules/fast-xml-parser/src/xmlparser/node2json.js","webpack://snap/../node_modules/fast-xml-parser/src/xmlparser/xmlNode.js","webpack://snap/../node_modules/is-svg/index.js","webpack://snap/../node_modules/strnum/strnum.js","webpack://snap/./src/index.ts","webpack://snap/javascript/node_modules/@metamask/utils/dist/chunk-H4YFDLB7.mjs","webpack://snap/javascript/node_modules/superstruct/dist/index.mjs","webpack://snap/javascript/node_modules/@metamask/utils/dist/chunk-74DGVJVE.mjs","webpack://snap/javascript/node_modules/@metamask/utils/dist/chunk-XYGUOY6N.mjs","webpack://snap/javascript/node_modules/@metamask/utils/dist/chunk-6C35XQOF.mjs","webpack://snap/./node_modules/@metamask/snaps-sdk/dist/esm/internals/errors.js","webpack://snap/./node_modules/@metamask/snaps-sdk/dist/esm/internals/structs.js","webpack://snap/./node_modules/@metamask/snaps-sdk/dist/esm/errors.js","webpack://snap/./node_modules/@metamask/snaps-sdk/dist/esm/types/handlers/transaction.js","webpack://snap/./node_modules/@metamask/snaps-sdk/dist/esm/types/methods/dialog.js","webpack://snap/./node_modules/@metamask/snaps-sdk/dist/esm/types/methods/get-file.js","webpack://snap/./node_modules/@metamask/snaps-sdk/dist/esm/types/methods/manage-state.js","webpack://snap/./node_modules/@metamask/snaps-sdk/dist/esm/types/methods/notify.js","webpack://snap/./node_modules/@metamask/snaps-sdk/dist/esm/ui/nodes.js","webpack://snap/./node_modules/@metamask/snaps-sdk/dist/esm/ui/builder.js","webpack://snap/./node_modules/@metamask/snaps-sdk/dist/esm/ui/components/address.js","webpack://snap/./node_modules/@metamask/snaps-sdk/dist/esm/ui/components/copyable.js","webpack://snap/./node_modules/@metamask/snaps-sdk/dist/esm/ui/components/divider.js","webpack://snap/./node_modules/@metamask/snaps-sdk/dist/esm/ui/components/heading.js","webpack://snap/./node_modules/@metamask/snaps-sdk/dist/esm/ui/components/image.js","webpack://snap/./node_modules/@metamask/snaps-sdk/dist/esm/ui/components/text.js","webpack://snap/./node_modules/@metamask/snaps-sdk/dist/esm/ui/components/row.js","webpack://snap/./node_modules/@metamask/snaps-sdk/dist/esm/ui/components/spinner.js","webpack://snap/./node_modules/@metamask/snaps-sdk/dist/esm/ui/components/panel.js","webpack://snap/./node_modules/@metamask/snaps-sdk/dist/esm/ui/component.js","webpack://snap/webpack/bootstrap","webpack://snap/webpack/runtime/compat get default export","webpack://snap/webpack/runtime/define property getters","webpack://snap/webpack/runtime/hasOwnProperty shorthand","webpack://snap/webpack/runtime/make namespace object","webpack://snap/webpack/startup"],"sourcesContent":["'use strict';\n\nconst validator = require('./validator');\nconst XMLParser = require('./xmlparser/XMLParser');\nconst XMLBuilder = require('./xmlbuilder/json2xml');\n\nmodule.exports = {\n  XMLParser: XMLParser,\n  XMLValidator: validator,\n  XMLBuilder: XMLBuilder\n}","'use strict';\n\nconst nameStartChar = ':A-Za-z_\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD';\nconst nameChar = nameStartChar + '\\\\-.\\\\d\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040';\nconst nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*'\nconst regexName = new RegExp('^' + nameRegexp + '$');\n\nconst getAllMatches = function(string, regex) {\n  const matches = [];\n  let match = regex.exec(string);\n  while (match) {\n    const allmatches = [];\n    allmatches.startIndex = regex.lastIndex - match[0].length;\n    const len = match.length;\n    for (let index = 0; index < len; index++) {\n      allmatches.push(match[index]);\n    }\n    matches.push(allmatches);\n    match = regex.exec(string);\n  }\n  return matches;\n};\n\nconst isName = function(string) {\n  const match = regexName.exec(string);\n  return !(match === null || typeof match === 'undefined');\n};\n\nexports.isExist = function(v) {\n  return typeof v !== 'undefined';\n};\n\nexports.isEmptyObject = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\n/**\n * Copy all the properties of a into b.\n * @param {*} target\n * @param {*} a\n */\nexports.merge = function(target, a, arrayMode) {\n  if (a) {\n    const keys = Object.keys(a); // will return an array of own properties\n    const len = keys.length; //don't make it inline\n    for (let i = 0; i < len; i++) {\n      if (arrayMode === 'strict') {\n        target[keys[i]] = [ a[keys[i]] ];\n      } else {\n        target[keys[i]] = a[keys[i]];\n      }\n    }\n  }\n};\n/* exports.merge =function (b,a){\n  return Object.assign(b,a);\n} */\n\nexports.getValue = function(v) {\n  if (exports.isExist(v)) {\n    return v;\n  } else {\n    return '';\n  }\n};\n\n// const fakeCall = function(a) {return a;};\n// const fakeCallNoReturn = function() {};\n\nexports.isName = isName;\nexports.getAllMatches = getAllMatches;\nexports.nameRegexp = nameRegexp;\n","'use strict';\n\nconst util = require('./util');\n\nconst defaultOptions = {\n  allowBooleanAttributes: false, //A tag can have attributes without any value\n  unpairedTags: []\n};\n\n//const tagsPattern = new RegExp(\"<\\\\/?([\\\\w:\\\\-_\\.]+)\\\\s*\\/?>\",\"g\");\nexports.validate = function (xmlData, options) {\n  options = Object.assign({}, defaultOptions, options);\n\n  //xmlData = xmlData.replace(/(\\r\\n|\\n|\\r)/gm,\"\");//make it single line\n  //xmlData = xmlData.replace(/(^\\s*<\\?xml.*?\\?>)/g,\"\");//Remove XML starting tag\n  //xmlData = xmlData.replace(/(<!DOCTYPE[\\s\\w\\\"\\.\\/\\-\\:]+(\\[.*\\])*\\s*>)/g,\"\");//Remove DOCTYPE\n  const tags = [];\n  let tagFound = false;\n\n  //indicates that the root tag has been closed (aka. depth 0 has been reached)\n  let reachedRoot = false;\n\n  if (xmlData[0] === '\\ufeff') {\n    // check for byte order mark (BOM)\n    xmlData = xmlData.substr(1);\n  }\n  \n  for (let i = 0; i < xmlData.length; i++) {\n\n    if (xmlData[i] === '<' && xmlData[i+1] === '?') {\n      i+=2;\n      i = readPI(xmlData,i);\n      if (i.err) return i;\n    }else if (xmlData[i] === '<') {\n      //starting of tag\n      //read until you reach to '>' avoiding any '>' in attribute value\n      let tagStartPos = i;\n      i++;\n      \n      if (xmlData[i] === '!') {\n        i = readCommentAndCDATA(xmlData, i);\n        continue;\n      } else {\n        let closingTag = false;\n        if (xmlData[i] === '/') {\n          //closing tag\n          closingTag = true;\n          i++;\n        }\n        //read tagname\n        let tagName = '';\n        for (; i < xmlData.length &&\n          xmlData[i] !== '>' &&\n          xmlData[i] !== ' ' &&\n          xmlData[i] !== '\\t' &&\n          xmlData[i] !== '\\n' &&\n          xmlData[i] !== '\\r'; i++\n        ) {\n          tagName += xmlData[i];\n        }\n        tagName = tagName.trim();\n        //console.log(tagName);\n\n        if (tagName[tagName.length - 1] === '/') {\n          //self closing tag without attributes\n          tagName = tagName.substring(0, tagName.length - 1);\n          //continue;\n          i--;\n        }\n        if (!validateTagName(tagName)) {\n          let msg;\n          if (tagName.trim().length === 0) {\n            msg = \"Invalid space after '<'.\";\n          } else {\n            msg = \"Tag '\"+tagName+\"' is an invalid name.\";\n          }\n          return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));\n        }\n\n        const result = readAttributeStr(xmlData, i);\n        if (result === false) {\n          return getErrorObject('InvalidAttr', \"Attributes for '\"+tagName+\"' have open quote.\", getLineNumberForPosition(xmlData, i));\n        }\n        let attrStr = result.value;\n        i = result.index;\n\n        if (attrStr[attrStr.length - 1] === '/') {\n          //self closing tag\n          const attrStrStart = i - attrStr.length;\n          attrStr = attrStr.substring(0, attrStr.length - 1);\n          const isValid = validateAttributeString(attrStr, options);\n          if (isValid === true) {\n            tagFound = true;\n            //continue; //text may presents after self closing tag\n          } else {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));\n          }\n        } else if (closingTag) {\n          if (!result.tagClosed) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' doesn't have proper closing.\", getLineNumberForPosition(xmlData, i));\n          } else if (attrStr.trim().length > 0) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' can't have attributes or invalid starting.\", getLineNumberForPosition(xmlData, tagStartPos));\n          } else {\n            const otg = tags.pop();\n            if (tagName !== otg.tagName) {\n              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);\n              return getErrorObject('InvalidTag',\n                \"Expected closing tag '\"+otg.tagName+\"' (opened in line \"+openPos.line+\", col \"+openPos.col+\") instead of closing tag '\"+tagName+\"'.\",\n                getLineNumberForPosition(xmlData, tagStartPos));\n            }\n\n            //when there are no more tags, we reached the root level.\n            if (tags.length == 0) {\n              reachedRoot = true;\n            }\n          }\n        } else {\n          const isValid = validateAttributeString(attrStr, options);\n          if (isValid !== true) {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));\n          }\n\n          //if the root level has been reached before ...\n          if (reachedRoot === true) {\n            return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));\n          } else if(options.unpairedTags.indexOf(tagName) !== -1){\n            //don't push into stack\n          } else {\n            tags.push({tagName, tagStartPos});\n          }\n          tagFound = true;\n        }\n\n        //skip tag text value\n        //It may include comments and CDATA value\n        for (i++; i < xmlData.length; i++) {\n          if (xmlData[i] === '<') {\n            if (xmlData[i + 1] === '!') {\n              //comment or CADATA\n              i++;\n              i = readCommentAndCDATA(xmlData, i);\n              continue;\n            } else if (xmlData[i+1] === '?') {\n              i = readPI(xmlData, ++i);\n              if (i.err) return i;\n            } else{\n              break;\n            }\n          } else if (xmlData[i] === '&') {\n            const afterAmp = validateAmpersand(xmlData, i);\n            if (afterAmp == -1)\n              return getErrorObject('InvalidChar', \"char '&' is not expected.\", getLineNumberForPosition(xmlData, i));\n            i = afterAmp;\n          }else{\n            if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {\n              return getErrorObject('InvalidXml', \"Extra text at the end\", getLineNumberForPosition(xmlData, i));\n            }\n          }\n        } //end of reading tag text value\n        if (xmlData[i] === '<') {\n          i--;\n        }\n      }\n    } else {\n      if ( isWhiteSpace(xmlData[i])) {\n        continue;\n      }\n      return getErrorObject('InvalidChar', \"char '\"+xmlData[i]+\"' is not expected.\", getLineNumberForPosition(xmlData, i));\n    }\n  }\n\n  if (!tagFound) {\n    return getErrorObject('InvalidXml', 'Start tag expected.', 1);\n  }else if (tags.length == 1) {\n      return getErrorObject('InvalidTag', \"Unclosed tag '\"+tags[0].tagName+\"'.\", getLineNumberForPosition(xmlData, tags[0].tagStartPos));\n  }else if (tags.length > 0) {\n      return getErrorObject('InvalidXml', \"Invalid '\"+\n          JSON.stringify(tags.map(t => t.tagName), null, 4).replace(/\\r?\\n/g, '')+\n          \"' found.\", {line: 1, col: 1});\n  }\n\n  return true;\n};\n\nfunction isWhiteSpace(char){\n  return char === ' ' || char === '\\t' || char === '\\n'  || char === '\\r';\n}\n/**\n * Read Processing insstructions and skip\n * @param {*} xmlData\n * @param {*} i\n */\nfunction readPI(xmlData, i) {\n  const start = i;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] == '?' || xmlData[i] == ' ') {\n      //tagname\n      const tagname = xmlData.substr(start, i - start);\n      if (i > 5 && tagname === 'xml') {\n        return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));\n      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {\n        //check if valid attribut string\n        i++;\n        break;\n      } else {\n        continue;\n      }\n    }\n  }\n  return i;\n}\n\nfunction readCommentAndCDATA(xmlData, i) {\n  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {\n    //comment\n    for (i += 3; i < xmlData.length; i++) {\n      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  } else if (\n    xmlData.length > i + 8 &&\n    xmlData[i + 1] === 'D' &&\n    xmlData[i + 2] === 'O' &&\n    xmlData[i + 3] === 'C' &&\n    xmlData[i + 4] === 'T' &&\n    xmlData[i + 5] === 'Y' &&\n    xmlData[i + 6] === 'P' &&\n    xmlData[i + 7] === 'E'\n  ) {\n    let angleBracketsCount = 1;\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === '<') {\n        angleBracketsCount++;\n      } else if (xmlData[i] === '>') {\n        angleBracketsCount--;\n        if (angleBracketsCount === 0) {\n          break;\n        }\n      }\n    }\n  } else if (\n    xmlData.length > i + 9 &&\n    xmlData[i + 1] === '[' &&\n    xmlData[i + 2] === 'C' &&\n    xmlData[i + 3] === 'D' &&\n    xmlData[i + 4] === 'A' &&\n    xmlData[i + 5] === 'T' &&\n    xmlData[i + 6] === 'A' &&\n    xmlData[i + 7] === '['\n  ) {\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  }\n\n  return i;\n}\n\nconst doubleQuote = '\"';\nconst singleQuote = \"'\";\n\n/**\n * Keep reading xmlData until '<' is found outside the attribute value.\n * @param {string} xmlData\n * @param {number} i\n */\nfunction readAttributeStr(xmlData, i) {\n  let attrStr = '';\n  let startChar = '';\n  let tagClosed = false;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\n      if (startChar === '') {\n        startChar = xmlData[i];\n      } else if (startChar !== xmlData[i]) {\n        //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa\n      } else {\n        startChar = '';\n      }\n    } else if (xmlData[i] === '>') {\n      if (startChar === '') {\n        tagClosed = true;\n        break;\n      }\n    }\n    attrStr += xmlData[i];\n  }\n  if (startChar !== '') {\n    return false;\n  }\n\n  return {\n    value: attrStr,\n    index: i,\n    tagClosed: tagClosed\n  };\n}\n\n/**\n * Select all the attributes whether valid or invalid.\n */\nconst validAttrStrRegxp = new RegExp('(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*([\\'\"])(([\\\\s\\\\S])*?)\\\\5)?', 'g');\n\n//attr, =\"sd\", a=\"amit's\", a=\"sd\"b=\"saf\", ab  cd=\"\"\n\nfunction validateAttributeString(attrStr, options) {\n  //console.log(\"start:\"+attrStr+\":end\");\n\n  //if(attrStr.trim().length === 0) return true; //empty string\n\n  const matches = util.getAllMatches(attrStr, validAttrStrRegxp);\n  const attrNames = {};\n\n  for (let i = 0; i < matches.length; i++) {\n    if (matches[i][1].length === 0) {\n      //nospace before attribute name: a=\"sd\"b=\"saf\"\n      return getErrorObject('InvalidAttr', \"Attribute '\"+matches[i][2]+\"' has no space in starting.\", getPositionFromMatch(matches[i]))\n    } else if (matches[i][3] !== undefined && matches[i][4] === undefined) {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+matches[i][2]+\"' is without value.\", getPositionFromMatch(matches[i]));\n    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {\n      //independent attribute: ab\n      return getErrorObject('InvalidAttr', \"boolean attribute '\"+matches[i][2]+\"' is not allowed.\", getPositionFromMatch(matches[i]));\n    }\n    /* else if(matches[i][6] === undefined){//attribute without value: ab=\n                    return { err: { code:\"InvalidAttr\",msg:\"attribute \" + matches[i][2] + \" has no value assigned.\"}};\n                } */\n    const attrName = matches[i][2];\n    if (!validateAttrName(attrName)) {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+attrName+\"' is an invalid name.\", getPositionFromMatch(matches[i]));\n    }\n    if (!attrNames.hasOwnProperty(attrName)) {\n      //check for duplicate attribute.\n      attrNames[attrName] = 1;\n    } else {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+attrName+\"' is repeated.\", getPositionFromMatch(matches[i]));\n    }\n  }\n\n  return true;\n}\n\nfunction validateNumberAmpersand(xmlData, i) {\n  let re = /\\d/;\n  if (xmlData[i] === 'x') {\n    i++;\n    re = /[\\da-fA-F]/;\n  }\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === ';')\n      return i;\n    if (!xmlData[i].match(re))\n      break;\n  }\n  return -1;\n}\n\nfunction validateAmpersand(xmlData, i) {\n  // https://www.w3.org/TR/xml/#dt-charref\n  i++;\n  if (xmlData[i] === ';')\n    return -1;\n  if (xmlData[i] === '#') {\n    i++;\n    return validateNumberAmpersand(xmlData, i);\n  }\n  let count = 0;\n  for (; i < xmlData.length; i++, count++) {\n    if (xmlData[i].match(/\\w/) && count < 20)\n      continue;\n    if (xmlData[i] === ';')\n      break;\n    return -1;\n  }\n  return i;\n}\n\nfunction getErrorObject(code, message, lineNumber) {\n  return {\n    err: {\n      code: code,\n      msg: message,\n      line: lineNumber.line || lineNumber,\n      col: lineNumber.col,\n    },\n  };\n}\n\nfunction validateAttrName(attrName) {\n  return util.isName(attrName);\n}\n\n// const startsWithXML = /^xml/i;\n\nfunction validateTagName(tagname) {\n  return util.isName(tagname) /* && !tagname.match(startsWithXML) */;\n}\n\n//this function returns the line number for the character at the given index\nfunction getLineNumberForPosition(xmlData, index) {\n  const lines = xmlData.substring(0, index).split(/\\r?\\n/);\n  return {\n    line: lines.length,\n\n    // column number is last line's length + 1, because column numbering starts at 1:\n    col: lines[lines.length - 1].length + 1\n  };\n}\n\n//this function returns the position of the first character of match within attrStr\nfunction getPositionFromMatch(match) {\n  return match.startIndex + match[1].length;\n}\n","'use strict';\n//parse Empty Node as self closing node\nconst buildFromOrderedJs = require('./orderedJs2Xml');\n\nconst defaultOptions = {\n  attributeNamePrefix: '@_',\n  attributesGroupName: false,\n  textNodeName: '#text',\n  ignoreAttributes: true,\n  cdataPropName: false,\n  format: false,\n  indentBy: '  ',\n  suppressEmptyNode: false,\n  suppressUnpairedNode: true,\n  suppressBooleanAttributes: true,\n  tagValueProcessor: function(key, a) {\n    return a;\n  },\n  attributeValueProcessor: function(attrName, a) {\n    return a;\n  },\n  preserveOrder: false,\n  commentPropName: false,\n  unpairedTags: [],\n  entities: [\n    { regex: new RegExp(\"&\", \"g\"), val: \"&amp;\" },//it must be on top\n    { regex: new RegExp(\">\", \"g\"), val: \"&gt;\" },\n    { regex: new RegExp(\"<\", \"g\"), val: \"&lt;\" },\n    { regex: new RegExp(\"\\'\", \"g\"), val: \"&apos;\" },\n    { regex: new RegExp(\"\\\"\", \"g\"), val: \"&quot;\" }\n  ],\n  processEntities: true,\n  stopNodes: [],\n  // transformTagName: false,\n  // transformAttributeName: false,\n  oneListGroup: false\n};\n\nfunction Builder(options) {\n  this.options = Object.assign({}, defaultOptions, options);\n  if (this.options.ignoreAttributes || this.options.attributesGroupName) {\n    this.isAttribute = function(/*a*/) {\n      return false;\n    };\n  } else {\n    this.attrPrefixLen = this.options.attributeNamePrefix.length;\n    this.isAttribute = isAttribute;\n  }\n\n  this.processTextOrObjNode = processTextOrObjNode\n\n  if (this.options.format) {\n    this.indentate = indentate;\n    this.tagEndChar = '>\\n';\n    this.newLine = '\\n';\n  } else {\n    this.indentate = function() {\n      return '';\n    };\n    this.tagEndChar = '>';\n    this.newLine = '';\n  }\n}\n\nBuilder.prototype.build = function(jObj) {\n  if(this.options.preserveOrder){\n    return buildFromOrderedJs(jObj, this.options);\n  }else {\n    if(Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1){\n      jObj = {\n        [this.options.arrayNodeName] : jObj\n      }\n    }\n    return this.j2x(jObj, 0).val;\n  }\n};\n\nBuilder.prototype.j2x = function(jObj, level) {\n  let attrStr = '';\n  let val = '';\n  for (let key in jObj) {\n    if(!Object.prototype.hasOwnProperty.call(jObj, key)) continue;\n    if (typeof jObj[key] === 'undefined') {\n      // supress undefined node only if it is not an attribute\n      if (this.isAttribute(key)) {\n        val += '';\n      }\n    } else if (jObj[key] === null) {\n      // null attribute should be ignored by the attribute list, but should not cause the tag closing\n      if (this.isAttribute(key)) {\n        val += '';\n      } else if (key[0] === '?') {\n        val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;\n      } else {\n        val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n      }\n      // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n    } else if (jObj[key] instanceof Date) {\n      val += this.buildTextValNode(jObj[key], key, '', level);\n    } else if (typeof jObj[key] !== 'object') {\n      //premitive type\n      const attr = this.isAttribute(key);\n      if (attr) {\n        attrStr += this.buildAttrPairStr(attr, '' + jObj[key]);\n      }else {\n        //tag value\n        if (key === this.options.textNodeName) {\n          let newval = this.options.tagValueProcessor(key, '' + jObj[key]);\n          val += this.replaceEntitiesValue(newval);\n        } else {\n          val += this.buildTextValNode(jObj[key], key, '', level);\n        }\n      }\n    } else if (Array.isArray(jObj[key])) {\n      //repeated nodes\n      const arrLen = jObj[key].length;\n      let listTagVal = \"\";\n      for (let j = 0; j < arrLen; j++) {\n        const item = jObj[key][j];\n        if (typeof item === 'undefined') {\n          // supress undefined node\n        } else if (item === null) {\n          if(key[0] === \"?\") val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;\n          else val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n          // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n        } else if (typeof item === 'object') {\n          if(this.options.oneListGroup ){\n            listTagVal += this.j2x(item, level + 1).val;\n          }else{\n            listTagVal += this.processTextOrObjNode(item, key, level)\n          }\n        } else {\n          listTagVal += this.buildTextValNode(item, key, '', level);\n        }\n      }\n      if(this.options.oneListGroup){\n        listTagVal = this.buildObjectNode(listTagVal, key, '', level);\n      }\n      val += listTagVal;\n    } else {\n      //nested node\n      if (this.options.attributesGroupName && key === this.options.attributesGroupName) {\n        const Ks = Object.keys(jObj[key]);\n        const L = Ks.length;\n        for (let j = 0; j < L; j++) {\n          attrStr += this.buildAttrPairStr(Ks[j], '' + jObj[key][Ks[j]]);\n        }\n      } else {\n        val += this.processTextOrObjNode(jObj[key], key, level)\n      }\n    }\n  }\n  return {attrStr: attrStr, val: val};\n};\n\nBuilder.prototype.buildAttrPairStr = function(attrName, val){\n  val = this.options.attributeValueProcessor(attrName, '' + val);\n  val = this.replaceEntitiesValue(val);\n  if (this.options.suppressBooleanAttributes && val === \"true\") {\n    return ' ' + attrName;\n  } else return ' ' + attrName + '=\"' + val + '\"';\n}\n\nfunction processTextOrObjNode (object, key, level) {\n  const result = this.j2x(object, level + 1);\n  if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {\n    return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);\n  } else {\n    return this.buildObjectNode(result.val, key, result.attrStr, level);\n  }\n}\n\nBuilder.prototype.buildObjectNode = function(val, key, attrStr, level) {\n  if(val === \"\"){\n    if(key[0] === \"?\") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;\n    else {\n      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;\n    }\n  }else{\n\n    let tagEndExp = '</' + key + this.tagEndChar;\n    let piClosingChar = \"\";\n    \n    if(key[0] === \"?\") {\n      piClosingChar = \"?\";\n      tagEndExp = \"\";\n    }\n  \n    // attrStr is an empty string in case the attribute came as undefined or null\n    if ((attrStr || attrStr === '') && val.indexOf('<') === -1) {\n      return ( this.indentate(level) + '<' +  key + attrStr + piClosingChar + '>' + val + tagEndExp );\n    } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {\n      return this.indentate(level) + `<!--${val}-->` + this.newLine;\n    }else {\n      return (\n        this.indentate(level) + '<' + key + attrStr + piClosingChar + this.tagEndChar +\n        val +\n        this.indentate(level) + tagEndExp    );\n    }\n  }\n}\n\nBuilder.prototype.closeTag = function(key){\n  let closeTag = \"\";\n  if(this.options.unpairedTags.indexOf(key) !== -1){ //unpaired\n    if(!this.options.suppressUnpairedNode) closeTag = \"/\"\n  }else if(this.options.suppressEmptyNode){ //empty\n    closeTag = \"/\";\n  }else{\n    closeTag = `></${key}`\n  }\n  return closeTag;\n}\n\nfunction buildEmptyObjNode(val, key, attrStr, level) {\n  if (val !== '') {\n    return this.buildObjectNode(val, key, attrStr, level);\n  } else {\n    if(key[0] === \"?\") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;\n    else {\n      return  this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;\n      // return this.buildTagStr(level,key, attrStr);\n    }\n  }\n}\n\nBuilder.prototype.buildTextValNode = function(val, key, attrStr, level) {\n  if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {\n    return this.indentate(level) + `<![CDATA[${val}]]>` +  this.newLine;\n  }else if (this.options.commentPropName !== false && key === this.options.commentPropName) {\n    return this.indentate(level) + `<!--${val}-->` +  this.newLine;\n  }else if(key[0] === \"?\") {//PI tag\n    return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar; \n  }else{\n    let textValue = this.options.tagValueProcessor(key, val);\n    textValue = this.replaceEntitiesValue(textValue);\n  \n    if( textValue === ''){\n      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;\n    }else{\n      return this.indentate(level) + '<' + key + attrStr + '>' +\n         textValue +\n        '</' + key + this.tagEndChar;\n    }\n  }\n}\n\nBuilder.prototype.replaceEntitiesValue = function(textValue){\n  if(textValue && textValue.length > 0 && this.options.processEntities){\n    for (let i=0; i<this.options.entities.length; i++) {\n      const entity = this.options.entities[i];\n      textValue = textValue.replace(entity.regex, entity.val);\n    }\n  }\n  return textValue;\n}\n\nfunction indentate(level) {\n  return this.options.indentBy.repeat(level);\n}\n\nfunction isAttribute(name /*, options*/) {\n  if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {\n    return name.substr(this.attrPrefixLen);\n  } else {\n    return false;\n  }\n}\n\nmodule.exports = Builder;\n","const EOL = \"\\n\";\n\n/**\n * \n * @param {array} jArray \n * @param {any} options \n * @returns \n */\nfunction toXml(jArray, options) {\n    let indentation = \"\";\n    if (options.format && options.indentBy.length > 0) {\n        indentation = EOL;\n    }\n    return arrToStr(jArray, options, \"\", indentation);\n}\n\nfunction arrToStr(arr, options, jPath, indentation) {\n    let xmlStr = \"\";\n    let isPreviousElementTag = false;\n\n    for (let i = 0; i < arr.length; i++) {\n        const tagObj = arr[i];\n        const tagName = propName(tagObj);\n        if(tagName === undefined) continue;\n\n        let newJPath = \"\";\n        if (jPath.length === 0) newJPath = tagName\n        else newJPath = `${jPath}.${tagName}`;\n\n        if (tagName === options.textNodeName) {\n            let tagText = tagObj[tagName];\n            if (!isStopNode(newJPath, options)) {\n                tagText = options.tagValueProcessor(tagName, tagText);\n                tagText = replaceEntitiesValue(tagText, options);\n            }\n            if (isPreviousElementTag) {\n                xmlStr += indentation;\n            }\n            xmlStr += tagText;\n            isPreviousElementTag = false;\n            continue;\n        } else if (tagName === options.cdataPropName) {\n            if (isPreviousElementTag) {\n                xmlStr += indentation;\n            }\n            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;\n            isPreviousElementTag = false;\n            continue;\n        } else if (tagName === options.commentPropName) {\n            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;\n            isPreviousElementTag = true;\n            continue;\n        } else if (tagName[0] === \"?\") {\n            const attStr = attr_to_str(tagObj[\":@\"], options);\n            const tempInd = tagName === \"?xml\" ? \"\" : indentation;\n            let piTextNodeName = tagObj[tagName][0][options.textNodeName];\n            piTextNodeName = piTextNodeName.length !== 0 ? \" \" + piTextNodeName : \"\"; //remove extra spacing\n            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;\n            isPreviousElementTag = true;\n            continue;\n        }\n        let newIdentation = indentation;\n        if (newIdentation !== \"\") {\n            newIdentation += options.indentBy;\n        }\n        const attStr = attr_to_str(tagObj[\":@\"], options);\n        const tagStart = indentation + `<${tagName}${attStr}`;\n        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);\n        if (options.unpairedTags.indexOf(tagName) !== -1) {\n            if (options.suppressUnpairedNode) xmlStr += tagStart + \">\";\n            else xmlStr += tagStart + \"/>\";\n        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {\n            xmlStr += tagStart + \"/>\";\n        } else if (tagValue && tagValue.endsWith(\">\")) {\n            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;\n        } else {\n            xmlStr += tagStart + \">\";\n            if (tagValue && indentation !== \"\" && (tagValue.includes(\"/>\") || tagValue.includes(\"</\"))) {\n                xmlStr += indentation + options.indentBy + tagValue + indentation;\n            } else {\n                xmlStr += tagValue;\n            }\n            xmlStr += `</${tagName}>`;\n        }\n        isPreviousElementTag = true;\n    }\n\n    return xmlStr;\n}\n\nfunction propName(obj) {\n    const keys = Object.keys(obj);\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        if(!obj.hasOwnProperty(key)) continue;\n        if (key !== \":@\") return key;\n    }\n}\n\nfunction attr_to_str(attrMap, options) {\n    let attrStr = \"\";\n    if (attrMap && !options.ignoreAttributes) {\n        for (let attr in attrMap) {\n            if(!attrMap.hasOwnProperty(attr)) continue;\n            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);\n            attrVal = replaceEntitiesValue(attrVal, options);\n            if (attrVal === true && options.suppressBooleanAttributes) {\n                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;\n            } else {\n                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}=\"${attrVal}\"`;\n            }\n        }\n    }\n    return attrStr;\n}\n\nfunction isStopNode(jPath, options) {\n    jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);\n    let tagName = jPath.substr(jPath.lastIndexOf(\".\") + 1);\n    for (let index in options.stopNodes) {\n        if (options.stopNodes[index] === jPath || options.stopNodes[index] === \"*.\" + tagName) return true;\n    }\n    return false;\n}\n\nfunction replaceEntitiesValue(textValue, options) {\n    if (textValue && textValue.length > 0 && options.processEntities) {\n        for (let i = 0; i < options.entities.length; i++) {\n            const entity = options.entities[i];\n            textValue = textValue.replace(entity.regex, entity.val);\n        }\n    }\n    return textValue;\n}\nmodule.exports = toXml;\n","const util = require('../util');\n\n//TODO: handle comments\nfunction readDocType(xmlData, i){\n    \n    const entities = {};\n    if( xmlData[i + 3] === 'O' &&\n         xmlData[i + 4] === 'C' &&\n         xmlData[i + 5] === 'T' &&\n         xmlData[i + 6] === 'Y' &&\n         xmlData[i + 7] === 'P' &&\n         xmlData[i + 8] === 'E')\n    {    \n        i = i+9;\n        let angleBracketsCount = 1;\n        let hasBody = false, comment = false;\n        let exp = \"\";\n        for(;i<xmlData.length;i++){\n            if (xmlData[i] === '<' && !comment) { //Determine the tag type\n                if( hasBody && isEntity(xmlData, i)){\n                    i += 7; \n                    [entityName, val,i] = readEntityExp(xmlData,i+1);\n                    if(val.indexOf(\"&\") === -1) //Parameter entities are not supported\n                        entities[ validateEntityName(entityName) ] = {\n                            regx : RegExp( `&${entityName};`,\"g\"),\n                            val: val\n                        };\n                }\n                else if( hasBody && isElement(xmlData, i))  i += 8;//Not supported\n                else if( hasBody && isAttlist(xmlData, i))  i += 8;//Not supported\n                else if( hasBody && isNotation(xmlData, i)) i += 9;//Not supported\n                else if( isComment)                         comment = true;\n                else                                        throw new Error(\"Invalid DOCTYPE\");\n\n                angleBracketsCount++;\n                exp = \"\";\n            } else if (xmlData[i] === '>') { //Read tag content\n                if(comment){\n                    if( xmlData[i - 1] === \"-\" && xmlData[i - 2] === \"-\"){\n                        comment = false;\n                        angleBracketsCount--;\n                    }\n                }else{\n                    angleBracketsCount--;\n                }\n                if (angleBracketsCount === 0) {\n                  break;\n                }\n            }else if( xmlData[i] === '['){\n                hasBody = true;\n            }else{\n                exp += xmlData[i];\n            }\n        }\n        if(angleBracketsCount !== 0){\n            throw new Error(`Unclosed DOCTYPE`);\n        }\n    }else{\n        throw new Error(`Invalid Tag instead of DOCTYPE`);\n    }\n    return {entities, i};\n}\n\nfunction readEntityExp(xmlData,i){\n    //External entities are not supported\n    //    <!ENTITY ext SYSTEM \"http://normal-website.com\" >\n\n    //Parameter entities are not supported\n    //    <!ENTITY entityname \"&anotherElement;\">\n\n    //Internal entities are supported\n    //    <!ENTITY entityname \"replacement text\">\n    \n    //read EntityName\n    let entityName = \"\";\n    for (; i < xmlData.length && (xmlData[i] !== \"'\" && xmlData[i] !== '\"' ); i++) {\n        // if(xmlData[i] === \" \") continue;\n        // else \n        entityName += xmlData[i];\n    }\n    entityName = entityName.trim();\n    if(entityName.indexOf(\" \") !== -1) throw new Error(\"External entites are not supported\");\n\n    //read Entity Value\n    const startChar = xmlData[i++];\n    let val = \"\"\n    for (; i < xmlData.length && xmlData[i] !== startChar ; i++) {\n        val += xmlData[i];\n    }\n    return [entityName, val, i];\n}\n\nfunction isComment(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === '-' &&\n    xmlData[i+3] === '-') return true\n    return false\n}\nfunction isEntity(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'E' &&\n    xmlData[i+3] === 'N' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'I' &&\n    xmlData[i+6] === 'T' &&\n    xmlData[i+7] === 'Y') return true\n    return false\n}\nfunction isElement(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'E' &&\n    xmlData[i+3] === 'L' &&\n    xmlData[i+4] === 'E' &&\n    xmlData[i+5] === 'M' &&\n    xmlData[i+6] === 'E' &&\n    xmlData[i+7] === 'N' &&\n    xmlData[i+8] === 'T') return true\n    return false\n}\n\nfunction isAttlist(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'A' &&\n    xmlData[i+3] === 'T' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'L' &&\n    xmlData[i+6] === 'I' &&\n    xmlData[i+7] === 'S' &&\n    xmlData[i+8] === 'T') return true\n    return false\n}\nfunction isNotation(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'N' &&\n    xmlData[i+3] === 'O' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'A' &&\n    xmlData[i+6] === 'T' &&\n    xmlData[i+7] === 'I' &&\n    xmlData[i+8] === 'O' &&\n    xmlData[i+9] === 'N') return true\n    return false\n}\n\nfunction validateEntityName(name){\n    if (util.isName(name))\n\treturn name;\n    else\n        throw new Error(`Invalid entity name ${name}`);\n}\n\nmodule.exports = readDocType;\n","\nconst defaultOptions = {\n    preserveOrder: false,\n    attributeNamePrefix: '@_',\n    attributesGroupName: false,\n    textNodeName: '#text',\n    ignoreAttributes: true,\n    removeNSPrefix: false, // remove NS from tag name or attribute name if true\n    allowBooleanAttributes: false, //a tag can have attributes without any value\n    //ignoreRootElement : false,\n    parseTagValue: true,\n    parseAttributeValue: false,\n    trimValues: true, //Trim string values of tag and attributes\n    cdataPropName: false,\n    numberParseOptions: {\n      hex: true,\n      leadingZeros: true,\n      eNotation: true\n    },\n    tagValueProcessor: function(tagName, val) {\n      return val;\n    },\n    attributeValueProcessor: function(attrName, val) {\n      return val;\n    },\n    stopNodes: [], //nested tags will not be parsed even for errors\n    alwaysCreateTextNode: false,\n    isArray: () => false,\n    commentPropName: false,\n    unpairedTags: [],\n    processEntities: true,\n    htmlEntities: false,\n    ignoreDeclaration: false,\n    ignorePiTags: false,\n    transformTagName: false,\n    transformAttributeName: false,\n    updateTag: function(tagName, jPath, attrs){\n      return tagName\n    },\n    // skipEmptyListItem: false\n};\n   \nconst buildOptions = function(options) {\n    return Object.assign({}, defaultOptions, options);\n};\n\nexports.buildOptions = buildOptions;\nexports.defaultOptions = defaultOptions;","'use strict';\n///@ts-check\n\nconst util = require('../util');\nconst xmlNode = require('./xmlNode');\nconst readDocType = require(\"./DocTypeReader\");\nconst toNumber = require(\"strnum\");\n\n// const regx =\n//   '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)'\n//   .replace(/NAME/g, util.nameRegexp);\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\nclass OrderedObjParser{\n  constructor(options){\n    this.options = options;\n    this.currentNode = null;\n    this.tagsNodeStack = [];\n    this.docTypeEntities = {};\n    this.lastEntities = {\n      \"apos\" : { regex: /&(apos|#39|#x27);/g, val : \"'\"},\n      \"gt\" : { regex: /&(gt|#62|#x3E);/g, val : \">\"},\n      \"lt\" : { regex: /&(lt|#60|#x3C);/g, val : \"<\"},\n      \"quot\" : { regex: /&(quot|#34|#x22);/g, val : \"\\\"\"},\n    };\n    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val : \"&\"};\n    this.htmlEntities = {\n      \"space\": { regex: /&(nbsp|#160);/g, val: \" \" },\n      // \"lt\" : { regex: /&(lt|#60);/g, val: \"<\" },\n      // \"gt\" : { regex: /&(gt|#62);/g, val: \">\" },\n      // \"amp\" : { regex: /&(amp|#38);/g, val: \"&\" },\n      // \"quot\" : { regex: /&(quot|#34);/g, val: \"\\\"\" },\n      // \"apos\" : { regex: /&(apos|#39);/g, val: \"'\" },\n      \"cent\" : { regex: /&(cent|#162);/g, val: \"\" },\n      \"pound\" : { regex: /&(pound|#163);/g, val: \"\" },\n      \"yen\" : { regex: /&(yen|#165);/g, val: \"\" },\n      \"euro\" : { regex: /&(euro|#8364);/g, val: \"\" },\n      \"copyright\" : { regex: /&(copy|#169);/g, val: \"\" },\n      \"reg\" : { regex: /&(reg|#174);/g, val: \"\" },\n      \"inr\" : { regex: /&(inr|#8377);/g, val: \"\" },\n    };\n    this.addExternalEntities = addExternalEntities;\n    this.parseXml = parseXml;\n    this.parseTextData = parseTextData;\n    this.resolveNameSpace = resolveNameSpace;\n    this.buildAttributesMap = buildAttributesMap;\n    this.isItStopNode = isItStopNode;\n    this.replaceEntitiesValue = replaceEntitiesValue;\n    this.readStopNodeData = readStopNodeData;\n    this.saveTextToParentTag = saveTextToParentTag;\n    this.addChild = addChild;\n  }\n\n}\n\nfunction addExternalEntities(externalEntities){\n  const entKeys = Object.keys(externalEntities);\n  for (let i = 0; i < entKeys.length; i++) {\n    const ent = entKeys[i];\n    this.lastEntities[ent] = {\n       regex: new RegExp(\"&\"+ent+\";\",\"g\"),\n       val : externalEntities[ent]\n    }\n  }\n}\n\n/**\n * @param {string} val\n * @param {string} tagName\n * @param {string} jPath\n * @param {boolean} dontTrim\n * @param {boolean} hasAttributes\n * @param {boolean} isLeafNode\n * @param {boolean} escapeEntities\n */\nfunction parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {\n  if (val !== undefined) {\n    if (this.options.trimValues && !dontTrim) {\n      val = val.trim();\n    }\n    if(val.length > 0){\n      if(!escapeEntities) val = this.replaceEntitiesValue(val);\n      \n      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);\n      if(newval === null || newval === undefined){\n        //don't parse\n        return val;\n      }else if(typeof newval !== typeof val || newval !== val){\n        //overwrite\n        return newval;\n      }else if(this.options.trimValues){\n        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n      }else{\n        const trimmedVal = val.trim();\n        if(trimmedVal === val){\n          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n        }else{\n          return val;\n        }\n      }\n    }\n  }\n}\n\nfunction resolveNameSpace(tagname) {\n  if (this.options.removeNSPrefix) {\n    const tags = tagname.split(':');\n    const prefix = tagname.charAt(0) === '/' ? '/' : '';\n    if (tags[0] === 'xmlns') {\n      return '';\n    }\n    if (tags.length === 2) {\n      tagname = prefix + tags[1];\n    }\n  }\n  return tagname;\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])([\\\\s\\\\S]*?)\\\\3)?', 'gm');\n\nfunction buildAttributesMap(attrStr, jPath, tagName) {\n  if (!this.options.ignoreAttributes && typeof attrStr === 'string') {\n    // attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n    //attrStr = attrStr || attrStr.trim();\n\n    const matches = util.getAllMatches(attrStr, attrsRegx);\n    const len = matches.length; //don't make it inline\n    const attrs = {};\n    for (let i = 0; i < len; i++) {\n      const attrName = this.resolveNameSpace(matches[i][1]);\n      let oldVal = matches[i][4];\n      let aName = this.options.attributeNamePrefix + attrName;\n      if (attrName.length) {\n        if (this.options.transformAttributeName) {\n          aName = this.options.transformAttributeName(aName);\n        }\n        if(aName === \"__proto__\") aName  = \"#__proto__\";\n        if (oldVal !== undefined) {\n          if (this.options.trimValues) {\n            oldVal = oldVal.trim();\n          }\n          oldVal = this.replaceEntitiesValue(oldVal);\n          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);\n          if(newVal === null || newVal === undefined){\n            //don't parse\n            attrs[aName] = oldVal;\n          }else if(typeof newVal !== typeof oldVal || newVal !== oldVal){\n            //overwrite\n            attrs[aName] = newVal;\n          }else{\n            //parse\n            attrs[aName] = parseValue(\n              oldVal,\n              this.options.parseAttributeValue,\n              this.options.numberParseOptions\n            );\n          }\n        } else if (this.options.allowBooleanAttributes) {\n          attrs[aName] = true;\n        }\n      }\n    }\n    if (!Object.keys(attrs).length) {\n      return;\n    }\n    if (this.options.attributesGroupName) {\n      const attrCollection = {};\n      attrCollection[this.options.attributesGroupName] = attrs;\n      return attrCollection;\n    }\n    return attrs\n  }\n}\n\nconst parseXml = function(xmlData) {\n  xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\"); //TODO: remove this line\n  const xmlObj = new xmlNode('!xml');\n  let currentNode = xmlObj;\n  let textData = \"\";\n  let jPath = \"\";\n  for(let i=0; i< xmlData.length; i++){//for each char in XML data\n    const ch = xmlData[i];\n    if(ch === '<'){\n      // const nextIndex = i+1;\n      // const _2ndChar = xmlData[nextIndex];\n      if( xmlData[i+1] === '/') {//Closing Tag\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\")\n        let tagName = xmlData.substring(i+2,closeIndex).trim();\n\n        if(this.options.removeNSPrefix){\n          const colonIndex = tagName.indexOf(\":\");\n          if(colonIndex !== -1){\n            tagName = tagName.substr(colonIndex+1);\n          }\n        }\n\n        if(this.options.transformTagName) {\n          tagName = this.options.transformTagName(tagName);\n        }\n\n        if(currentNode){\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        }\n\n        //check if last tag of nested tag was unpaired tag\n        const lastTagName = jPath.substring(jPath.lastIndexOf(\".\")+1);\n        if(tagName && this.options.unpairedTags.indexOf(tagName) !== -1 ){\n          throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);\n        }\n        let propIndex = 0\n        if(lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1 ){\n          propIndex = jPath.lastIndexOf('.', jPath.lastIndexOf('.')-1)\n          this.tagsNodeStack.pop();\n        }else{\n          propIndex = jPath.lastIndexOf(\".\");\n        }\n        jPath = jPath.substring(0, propIndex);\n\n        currentNode = this.tagsNodeStack.pop();//avoid recursion, set the parent tag scope\n        textData = \"\";\n        i = closeIndex;\n      } else if( xmlData[i+1] === '?') {\n\n        let tagData = readTagExp(xmlData,i, false, \"?>\");\n        if(!tagData) throw new Error(\"Pi Tag is not closed.\");\n\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        if( (this.options.ignoreDeclaration && tagData.tagName === \"?xml\") || this.options.ignorePiTags){\n\n        }else{\n  \n          const childNode = new xmlNode(tagData.tagName);\n          childNode.add(this.options.textNodeName, \"\");\n          \n          if(tagData.tagName !== tagData.tagExp && tagData.attrExpPresent){\n            childNode[\":@\"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);\n          }\n          this.addChild(currentNode, childNode, jPath)\n\n        }\n\n\n        i = tagData.closeIndex + 1;\n      } else if(xmlData.substr(i + 1, 3) === '!--') {\n        const endIndex = findClosingIndex(xmlData, \"-->\", i+4, \"Comment is not closed.\")\n        if(this.options.commentPropName){\n          const comment = xmlData.substring(i + 4, endIndex - 2);\n\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n\n          currentNode.add(this.options.commentPropName, [ { [this.options.textNodeName] : comment } ]);\n        }\n        i = endIndex;\n      } else if( xmlData.substr(i + 1, 2) === '!D') {\n        const result = readDocType(xmlData, i);\n        this.docTypeEntities = result.entities;\n        i = result.i;\n      }else if(xmlData.substr(i + 1, 2) === '![') {\n        const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2;\n        const tagExp = xmlData.substring(i + 9,closeIndex);\n\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n\n        //cdata should be set even if it is 0 length string\n        if(this.options.cdataPropName){\n          // let val = this.parseTextData(tagExp, this.options.cdataPropName, jPath + \".\" + this.options.cdataPropName, true, false, true);\n          // if(!val) val = \"\";\n          currentNode.add(this.options.cdataPropName, [ { [this.options.textNodeName] : tagExp } ]);\n        }else{\n          let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);\n          if(val == undefined) val = \"\";\n          currentNode.add(this.options.textNodeName, val);\n        }\n        \n        i = closeIndex + 2;\n      }else {//Opening tag\n        let result = readTagExp(xmlData,i, this.options.removeNSPrefix);\n        let tagName= result.tagName;\n        const rawTagName = result.rawTagName;\n        let tagExp = result.tagExp;\n        let attrExpPresent = result.attrExpPresent;\n        let closeIndex = result.closeIndex;\n\n        if (this.options.transformTagName) {\n          tagName = this.options.transformTagName(tagName);\n        }\n        \n        //save text as child node\n        if (currentNode && textData) {\n          if(currentNode.tagname !== '!xml'){\n            //when nested tag is found\n            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);\n          }\n        }\n\n        //check if last tag was unpaired tag\n        const lastTag = currentNode;\n        if(lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1 ){\n          currentNode = this.tagsNodeStack.pop();\n          jPath = jPath.substring(0, jPath.lastIndexOf(\".\"));\n        }\n        if(tagName !== xmlObj.tagname){\n          jPath += jPath ? \".\" + tagName : tagName;\n        }\n        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {\n          let tagContent = \"\";\n          //self-closing tag\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){\n            i = result.closeIndex;\n          }\n          //unpaired tag\n          else if(this.options.unpairedTags.indexOf(tagName) !== -1){\n            i = result.closeIndex;\n          }\n          //normal tag\n          else{\n            //read until closing tag is found\n            const result = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);\n            if(!result) throw new Error(`Unexpected end of ${rawTagName}`);\n            i = result.i;\n            tagContent = result.tagContent;\n          }\n\n          const childNode = new xmlNode(tagName);\n          if(tagName !== tagExp && attrExpPresent){\n            childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n          }\n          if(tagContent) {\n            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);\n          }\n          \n          jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n          childNode.add(this.options.textNodeName, tagContent);\n          \n          this.addChild(currentNode, childNode, jPath)\n        }else{\n  //selfClosing tag\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){\n            if(tagName[tagName.length - 1] === \"/\"){ //remove trailing '/'\n              tagName = tagName.substr(0, tagName.length - 1);\n              jPath = jPath.substr(0, jPath.length - 1);\n              tagExp = tagName;\n            }else{\n              tagExp = tagExp.substr(0, tagExp.length - 1);\n            }\n            \n            if(this.options.transformTagName) {\n              tagName = this.options.transformTagName(tagName);\n            }\n\n            const childNode = new xmlNode(tagName);\n            if(tagName !== tagExp && attrExpPresent){\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n            }\n            this.addChild(currentNode, childNode, jPath)\n            jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n          }\n    //opening tag\n          else{\n            const childNode = new xmlNode( tagName);\n            this.tagsNodeStack.push(currentNode);\n            \n            if(tagName !== tagExp && attrExpPresent){\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n            }\n            this.addChild(currentNode, childNode, jPath)\n            currentNode = childNode;\n          }\n          textData = \"\";\n          i = closeIndex;\n        }\n      }\n    }else{\n      textData += xmlData[i];\n    }\n  }\n  return xmlObj.child;\n}\n\nfunction addChild(currentNode, childNode, jPath){\n  const result = this.options.updateTag(childNode.tagname, jPath, childNode[\":@\"])\n  if(result === false){\n  }else if(typeof result === \"string\"){\n    childNode.tagname = result\n    currentNode.addChild(childNode);\n  }else{\n    currentNode.addChild(childNode);\n  }\n}\n\nconst replaceEntitiesValue = function(val){\n\n  if(this.options.processEntities){\n    for(let entityName in this.docTypeEntities){\n      const entity = this.docTypeEntities[entityName];\n      val = val.replace( entity.regx, entity.val);\n    }\n    for(let entityName in this.lastEntities){\n      const entity = this.lastEntities[entityName];\n      val = val.replace( entity.regex, entity.val);\n    }\n    if(this.options.htmlEntities){\n      for(let entityName in this.htmlEntities){\n        const entity = this.htmlEntities[entityName];\n        val = val.replace( entity.regex, entity.val);\n      }\n    }\n    val = val.replace( this.ampEntity.regex, this.ampEntity.val);\n  }\n  return val;\n}\nfunction saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {\n  if (textData) { //store previously collected data as textNode\n    if(isLeafNode === undefined) isLeafNode = Object.keys(currentNode.child).length === 0\n    \n    textData = this.parseTextData(textData,\n      currentNode.tagname,\n      jPath,\n      false,\n      currentNode[\":@\"] ? Object.keys(currentNode[\":@\"]).length !== 0 : false,\n      isLeafNode);\n\n    if (textData !== undefined && textData !== \"\")\n      currentNode.add(this.options.textNodeName, textData);\n    textData = \"\";\n  }\n  return textData;\n}\n\n//TODO: use jPath to simplify the logic\n/**\n * \n * @param {string[]} stopNodes \n * @param {string} jPath\n * @param {string} currentTagName \n */\nfunction isItStopNode(stopNodes, jPath, currentTagName){\n  const allNodesExp = \"*.\" + currentTagName;\n  for (const stopNodePath in stopNodes) {\n    const stopNodeExp = stopNodes[stopNodePath];\n    if( allNodesExp === stopNodeExp || jPath === stopNodeExp  ) return true;\n  }\n  return false;\n}\n\n/**\n * Returns the tag Expression and where it is ending handling single-double quotes situation\n * @param {string} xmlData \n * @param {number} i starting index\n * @returns \n */\nfunction tagExpWithClosingIndex(xmlData, i, closingChar = \">\"){\n  let attrBoundary;\n  let tagExp = \"\";\n  for (let index = i; index < xmlData.length; index++) {\n    let ch = xmlData[index];\n    if (attrBoundary) {\n        if (ch === attrBoundary) attrBoundary = \"\";//reset\n    } else if (ch === '\"' || ch === \"'\") {\n        attrBoundary = ch;\n    } else if (ch === closingChar[0]) {\n      if(closingChar[1]){\n        if(xmlData[index + 1] === closingChar[1]){\n          return {\n            data: tagExp,\n            index: index\n          }\n        }\n      }else{\n        return {\n          data: tagExp,\n          index: index\n        }\n      }\n    } else if (ch === '\\t') {\n      ch = \" \"\n    }\n    tagExp += ch;\n  }\n}\n\nfunction findClosingIndex(xmlData, str, i, errMsg){\n  const closingIndex = xmlData.indexOf(str, i);\n  if(closingIndex === -1){\n    throw new Error(errMsg)\n  }else{\n    return closingIndex + str.length - 1;\n  }\n}\n\nfunction readTagExp(xmlData,i, removeNSPrefix, closingChar = \">\"){\n  const result = tagExpWithClosingIndex(xmlData, i+1, closingChar);\n  if(!result) return;\n  let tagExp = result.data;\n  const closeIndex = result.index;\n  const separatorIndex = tagExp.search(/\\s/);\n  let tagName = tagExp;\n  let attrExpPresent = true;\n  if(separatorIndex !== -1){//separate tag name and attributes expression\n    tagName = tagExp.substring(0, separatorIndex);\n    tagExp = tagExp.substring(separatorIndex + 1).trimStart();\n  }\n\n  const rawTagName = tagName;\n  if(removeNSPrefix){\n    const colonIndex = tagName.indexOf(\":\");\n    if(colonIndex !== -1){\n      tagName = tagName.substr(colonIndex+1);\n      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);\n    }\n  }\n\n  return {\n    tagName: tagName,\n    tagExp: tagExp,\n    closeIndex: closeIndex,\n    attrExpPresent: attrExpPresent,\n    rawTagName: rawTagName,\n  }\n}\n/**\n * find paired tag for a stop node\n * @param {string} xmlData \n * @param {string} tagName \n * @param {number} i \n */\nfunction readStopNodeData(xmlData, tagName, i){\n  const startIndex = i;\n  // Starting at 1 since we already have an open tag\n  let openTagCount = 1;\n\n  for (; i < xmlData.length; i++) {\n    if( xmlData[i] === \"<\"){ \n      if (xmlData[i+1] === \"/\") {//close tag\n          const closeIndex = findClosingIndex(xmlData, \">\", i, `${tagName} is not closed`);\n          let closeTagName = xmlData.substring(i+2,closeIndex).trim();\n          if(closeTagName === tagName){\n            openTagCount--;\n            if (openTagCount === 0) {\n              return {\n                tagContent: xmlData.substring(startIndex, i),\n                i : closeIndex\n              }\n            }\n          }\n          i=closeIndex;\n        } else if(xmlData[i+1] === '?') { \n          const closeIndex = findClosingIndex(xmlData, \"?>\", i+1, \"StopNode is not closed.\")\n          i=closeIndex;\n        } else if(xmlData.substr(i + 1, 3) === '!--') { \n          const closeIndex = findClosingIndex(xmlData, \"-->\", i+3, \"StopNode is not closed.\")\n          i=closeIndex;\n        } else if(xmlData.substr(i + 1, 2) === '![') { \n          const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"StopNode is not closed.\") - 2;\n          i=closeIndex;\n        } else {\n          const tagData = readTagExp(xmlData, i, '>')\n\n          if (tagData) {\n            const openTagName = tagData && tagData.tagName;\n            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length-1] !== \"/\") {\n              openTagCount++;\n            }\n            i=tagData.closeIndex;\n          }\n        }\n      }\n  }//end for loop\n}\n\nfunction parseValue(val, shouldParse, options) {\n  if (shouldParse && typeof val === 'string') {\n    //console.log(options)\n    const newval = val.trim();\n    if(newval === 'true' ) return true;\n    else if(newval === 'false' ) return false;\n    else return toNumber(val, options);\n  } else {\n    if (util.isExist(val)) {\n      return val;\n    } else {\n      return '';\n    }\n  }\n}\n\n\nmodule.exports = OrderedObjParser;\n","const { buildOptions} = require(\"./OptionsBuilder\");\nconst OrderedObjParser = require(\"./OrderedObjParser\");\nconst { prettify} = require(\"./node2json\");\nconst validator = require('../validator');\n\nclass XMLParser{\n    \n    constructor(options){\n        this.externalEntities = {};\n        this.options = buildOptions(options);\n        \n    }\n    /**\n     * Parse XML dats to JS object \n     * @param {string|Buffer} xmlData \n     * @param {boolean|Object} validationOption \n     */\n    parse(xmlData,validationOption){\n        if(typeof xmlData === \"string\"){\n        }else if( xmlData.toString){\n            xmlData = xmlData.toString();\n        }else{\n            throw new Error(\"XML data is accepted in String or Bytes[] form.\")\n        }\n        if( validationOption){\n            if(validationOption === true) validationOption = {}; //validate with default options\n            \n            const result = validator.validate(xmlData, validationOption);\n            if (result !== true) {\n              throw Error( `${result.err.msg}:${result.err.line}:${result.err.col}` )\n            }\n          }\n        const orderedObjParser = new OrderedObjParser(this.options);\n        orderedObjParser.addExternalEntities(this.externalEntities);\n        const orderedResult = orderedObjParser.parseXml(xmlData);\n        if(this.options.preserveOrder || orderedResult === undefined) return orderedResult;\n        else return prettify(orderedResult, this.options);\n    }\n\n    /**\n     * Add Entity which is not by default supported by this library\n     * @param {string} key \n     * @param {string} value \n     */\n    addEntity(key, value){\n        if(value.indexOf(\"&\") !== -1){\n            throw new Error(\"Entity value can't have '&'\")\n        }else if(key.indexOf(\"&\") !== -1 || key.indexOf(\";\") !== -1){\n            throw new Error(\"An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'\")\n        }else if(value === \"&\"){\n            throw new Error(\"An entity with value '&' is not permitted\");\n        }else{\n            this.externalEntities[key] = value;\n        }\n    }\n}\n\nmodule.exports = XMLParser;","'use strict';\n\n/**\n * \n * @param {array} node \n * @param {any} options \n * @returns \n */\nfunction prettify(node, options){\n  return compress( node, options);\n}\n\n/**\n * \n * @param {array} arr \n * @param {object} options \n * @param {string} jPath \n * @returns object\n */\nfunction compress(arr, options, jPath){\n  let text;\n  const compressedObj = {};\n  for (let i = 0; i < arr.length; i++) {\n    const tagObj = arr[i];\n    const property = propName(tagObj);\n    let newJpath = \"\";\n    if(jPath === undefined) newJpath = property;\n    else newJpath = jPath + \".\" + property;\n\n    if(property === options.textNodeName){\n      if(text === undefined) text = tagObj[property];\n      else text += \"\" + tagObj[property];\n    }else if(property === undefined){\n      continue;\n    }else if(tagObj[property]){\n      \n      let val = compress(tagObj[property], options, newJpath);\n      const isLeaf = isLeafTag(val, options);\n\n      if(tagObj[\":@\"]){\n        assignAttributes( val, tagObj[\":@\"], newJpath, options);\n      }else if(Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode){\n        val = val[options.textNodeName];\n      }else if(Object.keys(val).length === 0){\n        if(options.alwaysCreateTextNode) val[options.textNodeName] = \"\";\n        else val = \"\";\n      }\n\n      if(compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {\n        if(!Array.isArray(compressedObj[property])) {\n            compressedObj[property] = [ compressedObj[property] ];\n        }\n        compressedObj[property].push(val);\n      }else{\n        //TODO: if a node is not an array, then check if it should be an array\n        //also determine if it is a leaf node\n        if (options.isArray(property, newJpath, isLeaf )) {\n          compressedObj[property] = [val];\n        }else{\n          compressedObj[property] = val;\n        }\n      }\n    }\n    \n  }\n  // if(text && text.length > 0) compressedObj[options.textNodeName] = text;\n  if(typeof text === \"string\"){\n    if(text.length > 0) compressedObj[options.textNodeName] = text;\n  }else if(text !== undefined) compressedObj[options.textNodeName] = text;\n  return compressedObj;\n}\n\nfunction propName(obj){\n  const keys = Object.keys(obj);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if(key !== \":@\") return key;\n  }\n}\n\nfunction assignAttributes(obj, attrMap, jpath, options){\n  if (attrMap) {\n    const keys = Object.keys(attrMap);\n    const len = keys.length; //don't make it inline\n    for (let i = 0; i < len; i++) {\n      const atrrName = keys[i];\n      if (options.isArray(atrrName, jpath + \".\" + atrrName, true, true)) {\n        obj[atrrName] = [ attrMap[atrrName] ];\n      } else {\n        obj[atrrName] = attrMap[atrrName];\n      }\n    }\n  }\n}\n\nfunction isLeafTag(obj, options){\n  const { textNodeName } = options;\n  const propCount = Object.keys(obj).length;\n  \n  if (propCount === 0) {\n    return true;\n  }\n\n  if (\n    propCount === 1 &&\n    (obj[textNodeName] || typeof obj[textNodeName] === \"boolean\" || obj[textNodeName] === 0)\n  ) {\n    return true;\n  }\n\n  return false;\n}\nexports.prettify = prettify;\n","'use strict';\n\nclass XmlNode{\n  constructor(tagname) {\n    this.tagname = tagname;\n    this.child = []; //nested tags, text, cdata, comments in order\n    this[\":@\"] = {}; //attributes map\n  }\n  add(key,val){\n    // this.child.push( {name : key, val: val, isCdata: isCdata });\n    if(key === \"__proto__\") key = \"#__proto__\";\n    this.child.push( {[key]: val });\n  }\n  addChild(node) {\n    if(node.tagname === \"__proto__\") node.tagname = \"#__proto__\";\n    if(node[\":@\"] && Object.keys(node[\":@\"]).length > 0){\n      this.child.push( { [node.tagname]: node.child, [\":@\"]: node[\":@\"] });\n    }else{\n      this.child.push( { [node.tagname]: node.child });\n    }\n  };\n};\n\n\nmodule.exports = XmlNode;","'use strict';\nconst {XMLParser, XMLValidator} = require('fast-xml-parser');\n\nconst isSvg = input => {\n\tif (input === undefined || input === null) {\n\t\treturn false;\n\t}\n\n\tinput = input.toString().trim();\n\n\tif (input.length === 0) {\n\t\treturn false;\n\t}\n\n\t// Has to be `!==` as it can also return an object with error info.\n\tif (XMLValidator.validate(input) !== true) {\n\t\treturn false;\n\t}\n\n\tlet jsonObject;\n\tconst parser = new XMLParser();\n\n\ttry {\n\t\tjsonObject = parser.parse(input);\n\t} catch (_) {\n\t\treturn false;\n\t}\n\n\tif (!jsonObject) {\n\t\treturn false;\n\t}\n\n\tif (!('svg' in jsonObject)) {\n\t\treturn false;\n\t}\n\n\treturn true;\n};\n\nmodule.exports = isSvg;\n// TODO: Remove this for the next major release\nmodule.exports.default = isSvg;\n","const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;\nconst numRegex = /^([\\-\\+])?(0*)(\\.[0-9]+([eE]\\-?[0-9]+)?|[0-9]+(\\.[0-9]+([eE]\\-?[0-9]+)?)?)$/;\n// const octRegex = /0x[a-z0-9]+/;\n// const binRegex = /0x[a-z0-9]+/;\n\n\n//polyfill\nif (!Number.parseInt && window.parseInt) {\n    Number.parseInt = window.parseInt;\n}\nif (!Number.parseFloat && window.parseFloat) {\n    Number.parseFloat = window.parseFloat;\n}\n\n  \nconst consider = {\n    hex :  true,\n    leadingZeros: true,\n    decimalPoint: \"\\.\",\n    eNotation: true\n    //skipLike: /regex/\n};\n\nfunction toNumber(str, options = {}){\n    // const options = Object.assign({}, consider);\n    // if(opt.leadingZeros === false){\n    //     options.leadingZeros = false;\n    // }else if(opt.hex === false){\n    //     options.hex = false;\n    // }\n\n    options = Object.assign({}, consider, options );\n    if(!str || typeof str !== \"string\" ) return str;\n    \n    let trimmedStr  = str.trim();\n    // if(trimmedStr === \"0.0\") return 0;\n    // else if(trimmedStr === \"+0.0\") return 0;\n    // else if(trimmedStr === \"-0.0\") return -0;\n\n    if(options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;\n    else if (options.hex && hexRegex.test(trimmedStr)) {\n        return Number.parseInt(trimmedStr, 16);\n    // } else if (options.parseOct && octRegex.test(str)) {\n    //     return Number.parseInt(val, 8);\n    // }else if (options.parseBin && binRegex.test(str)) {\n    //     return Number.parseInt(val, 2);\n    }else{\n        //separate negative sign, leading zeros, and rest number\n        const match = numRegex.exec(trimmedStr);\n        if(match){\n            const sign = match[1];\n            const leadingZeros = match[2];\n            let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros\n            //trim ending zeros for floating number\n            \n            const eNotation = match[4] || match[6];\n            if(!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== \".\") return str; //-0123\n            else if(!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== \".\") return str; //0123\n            else{//no leading zeros or leading zeros are allowed\n                const num = Number(trimmedStr);\n                const numStr = \"\" + num;\n                if(numStr.search(/[eE]/) !== -1){ //given number is long and parsed to eNotation\n                    if(options.eNotation) return num;\n                    else return str;\n                }else if(eNotation){ //given number has enotation\n                    if(options.eNotation) return num;\n                    else return str;\n                }else if(trimmedStr.indexOf(\".\") !== -1){ //floating number\n                    // const decimalPart = match[5].substr(1);\n                    // const intPart = trimmedStr.substr(0,trimmedStr.indexOf(\".\"));\n\n                    \n                    // const p = numStr.indexOf(\".\");\n                    // const givenIntPart = numStr.substr(0,p);\n                    // const givenDecPart = numStr.substr(p+1);\n                    if(numStr === \"0\" && (numTrimmedByZeros === \"\") ) return num; //0.0\n                    else if(numStr === numTrimmedByZeros) return num; //0.456. 0.79000\n                    else if( sign && numStr === \"-\"+numTrimmedByZeros) return num;\n                    else return str;\n                }\n                \n                if(leadingZeros){\n                    // if(numTrimmedByZeros === numStr){\n                    //     if(options.leadingZeros) return num;\n                    //     else return str;\n                    // }else return str;\n                    if(numTrimmedByZeros === numStr) return num;\n                    else if(sign+numTrimmedByZeros === numStr) return num;\n                    else return str;\n                }\n\n                if(trimmedStr === numStr) return num;\n                else if(trimmedStr === sign+numStr) return num;\n                // else{\n                //     //number with +/- sign\n                //     trimmedStr.test(/[-+][0-9]);\n\n                // }\n                return str;\n            }\n            // else if(!eNotation && trimmedStr && trimmedStr !== Number(trimmedStr) ) return str;\n            \n        }else{ //non-numeric string\n            return str;\n        }\n    }\n}\n\n/**\n * \n * @param {string} numStr without leading zeros\n * @returns \n */\nfunction trimZeros(numStr){\n    if(numStr && numStr.indexOf(\".\") !== -1){//float\n        numStr = numStr.replace(/0+$/, \"\"); //remove ending zeros\n        if(numStr === \".\")  numStr = \"0\";\n        else if(numStr[0] === \".\")  numStr = \"0\"+numStr;\n        else if(numStr[numStr.length-1] === \".\")  numStr = numStr.substr(0,numStr.length-1);\n        return numStr;\n    }\n    return numStr;\n}\nmodule.exports = toNumber\n","import { heading, OnCronjobHandler, OnRpcRequestHandler } from '@metamask/snaps-sdk';\nimport { panel, text } from '@metamask/snaps-sdk';\nimport { isObject, Json } from \"@metamask/utils\"\n\nasync function getNotification() {\n  const response = await fetch(\n    `https://aave-snap.vercel.app/api/notifications`\n    );\n  return response.text();\n}\n\nasync function getPoolInfo() {\n  const response = await fetch(\n    `https://aave-snap.vercel.app/api/pools`\n    );\n  return response.text();\n}\n\n/**\n * Handle incoming JSON-RPC requests, sent through `wallet_invokeSnap`.\n *\n * @param args - The request handler args as object.\n * @param args.origin - The origin of the request, e.g., the website that\n * invoked the snap.\n * @param args.request - A validated JSON-RPC request object.\n * @returns The result of `snap_dialog`.\n * @throws If the request method is not valid for this snap.\n */\nexport const onRpcRequest: OnRpcRequestHandler = async ({\n  origin,\n  request,\n}) => {\n  switch (request.method) {\n    case 'hello':\n      return getPoolInfo().then((response) => {\n        const { data } = JSON.parse(response)\n        return snap.request({\n          method: 'snap_dialog',\n          params: {\n            type: 'confirmation',\n            content: panel([\n              heading('AAVE Pools Infomations: '),\n              text(`Pool: ${data[0].name}`),\n              text(`APY: ${data[0].supplyAPY}`),\n              text(`IsIsolated: ${data[0].isIsolated}`),\n              text('-----------------------------'),\n              text(`Pool: ${data[1].name}`),\n              text(`APY: ${data[1].supplyAPY}`),\n              text(`IsIsolated: ${data[1].isIsolated}`),\n              text('-----------------------------'),\n              text(`Pool: ${data[2].name}`),\n              text(`APY: ${data[2].supplyAPY}`),\n              text(`IsIsolated: ${data[2].isIsolated}`),\n              text('-----------------------------'),\n              text(`Pool: ${data[3].name}`),\n              text(`APY: ${data[3].supplyAPY}`),\n              text(`IsIsolated: ${data[3].isIsolated}`),\n              text('-----------------------------'),\n              text(`Pool: ${data[4].name}`),\n              text(`APY: ${data[4].supplyAPY}`),\n              text(`IsIsolated: ${data[4].isIsolated}`),\n              text('-----------------------------'),\n              text(`Pool: ${data[5].name}`),\n              text(`APY: ${data[5].supplyAPY}`),\n              text(`IsIsolated: ${data[5].isIsolated}`),\n              text('-----------------------------'),\n              text(`Pool: ${data[6].name}`),\n              text(`APY: ${data[6].supplyAPY}`),\n              text(`IsIsolated: ${data[6].isIsolated}`),\n            ]),\n          },\n        });\n      })\n    default:\n      throw new Error('Method not found.');\n  }\n};\n\nexport const onCronjob: OnCronjobHandler = async ({ request }) => {\n  try {\n    switch (request.method) {\n      case 'notifyPoolChanged':\n        return getNotification().then( response => {\n          if(JSON.parse(response).notifications !== \"\" ) {\n            return snap.request({\n              method: 'snap_notify',\n              params: {\n                type: 'inApp',\n                message: JSON.parse(response).notifications,\n              },\n            });\n          }\n        })\n      default:\n      // throw new Error('Snap: Method not found.');\n    }\n  } catch (error) {\n    console.log(error);\n  }\n};\n","// src/misc.ts\nfunction isNonEmptyArray(value) {\n  return Array.isArray(value) && value.length > 0;\n}\nfunction isNullOrUndefined(value) {\n  return value === null || value === void 0;\n}\nfunction isObject(value) {\n  return Boolean(value) && typeof value === \"object\" && !Array.isArray(value);\n}\nvar hasProperty = (objectToCheck, name) => Object.hasOwnProperty.call(objectToCheck, name);\nfunction getKnownPropertyNames(object) {\n  return Object.getOwnPropertyNames(object);\n}\nvar JsonSize = /* @__PURE__ */ ((JsonSize2) => {\n  JsonSize2[JsonSize2[\"Null\"] = 4] = \"Null\";\n  JsonSize2[JsonSize2[\"Comma\"] = 1] = \"Comma\";\n  JsonSize2[JsonSize2[\"Wrapper\"] = 1] = \"Wrapper\";\n  JsonSize2[JsonSize2[\"True\"] = 4] = \"True\";\n  JsonSize2[JsonSize2[\"False\"] = 5] = \"False\";\n  JsonSize2[JsonSize2[\"Quote\"] = 1] = \"Quote\";\n  JsonSize2[JsonSize2[\"Colon\"] = 1] = \"Colon\";\n  JsonSize2[JsonSize2[\"Date\"] = 24] = \"Date\";\n  return JsonSize2;\n})(JsonSize || {});\nvar ESCAPE_CHARACTERS_REGEXP = /\"|\\\\|\\n|\\r|\\t/gu;\nfunction isPlainObject(value) {\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  try {\n    let proto = value;\n    while (Object.getPrototypeOf(proto) !== null) {\n      proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(value) === proto;\n  } catch (_) {\n    return false;\n  }\n}\nfunction isASCII(character) {\n  return character.charCodeAt(0) <= 127;\n}\nfunction calculateStringSize(value) {\n  const size = value.split(\"\").reduce((total, character) => {\n    if (isASCII(character)) {\n      return total + 1;\n    }\n    return total + 2;\n  }, 0);\n  return size + (value.match(ESCAPE_CHARACTERS_REGEXP) ?? []).length;\n}\nfunction calculateNumberSize(value) {\n  return value.toString().length;\n}\n\nexport {\n  isNonEmptyArray,\n  isNullOrUndefined,\n  isObject,\n  hasProperty,\n  getKnownPropertyNames,\n  JsonSize,\n  ESCAPE_CHARACTERS_REGEXP,\n  isPlainObject,\n  isASCII,\n  calculateStringSize,\n  calculateNumberSize\n};\n//# sourceMappingURL=chunk-H4YFDLB7.mjs.map","/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\nclass StructError extends TypeError {\n    constructor(failure, failures) {\n        let cached;\n        const { message, explanation, ...rest } = failure;\n        const { path } = failure;\n        const msg = path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`;\n        super(explanation ?? msg);\n        if (explanation != null)\n            this.cause = msg;\n        Object.assign(this, rest);\n        this.name = this.constructor.name;\n        this.failures = () => {\n            return (cached ?? (cached = [failure, ...failures()]));\n        };\n    }\n}\n\n/**\n * Check if a value is an iterator.\n */\nfunction isIterable(x) {\n    return isObject(x) && typeof x[Symbol.iterator] === 'function';\n}\n/**\n * Check if a value is a plain object.\n */\nfunction isObject(x) {\n    return typeof x === 'object' && x != null;\n}\n/**\n * Check if a value is a plain object.\n */\nfunction isPlainObject(x) {\n    if (Object.prototype.toString.call(x) !== '[object Object]') {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(x);\n    return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */\nfunction print(value) {\n    if (typeof value === 'symbol') {\n        return value.toString();\n    }\n    return typeof value === 'string' ? JSON.stringify(value) : `${value}`;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\nfunction shiftIterator(input) {\n    const { done, value } = input.next();\n    return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */\nfunction toFailure(result, context, struct, value) {\n    if (result === true) {\n        return;\n    }\n    else if (result === false) {\n        result = {};\n    }\n    else if (typeof result === 'string') {\n        result = { message: result };\n    }\n    const { path, branch } = context;\n    const { type } = struct;\n    const { refinement, message = `Expected a value of type \\`${type}\\`${refinement ? ` with refinement \\`${refinement}\\`` : ''}, but received: \\`${print(value)}\\``, } = result;\n    return {\n        value,\n        type,\n        refinement,\n        key: path[path.length - 1],\n        path,\n        branch,\n        ...result,\n        message,\n    };\n}\n/**\n * Convert a validation result to an iterable of failures.\n */\nfunction* toFailures(result, context, struct, value) {\n    if (!isIterable(result)) {\n        result = [result];\n    }\n    for (const r of result) {\n        const failure = toFailure(r, context, struct, value);\n        if (failure) {\n            yield failure;\n        }\n    }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */\nfunction* run(value, struct, options = {}) {\n    const { path = [], branch = [value], coerce = false, mask = false } = options;\n    const ctx = { path, branch };\n    if (coerce) {\n        value = struct.coercer(value, ctx);\n        if (mask &&\n            struct.type !== 'type' &&\n            isObject(struct.schema) &&\n            isObject(value) &&\n            !Array.isArray(value)) {\n            for (const key in value) {\n                if (struct.schema[key] === undefined) {\n                    delete value[key];\n                }\n            }\n        }\n    }\n    let status = 'valid';\n    for (const failure of struct.validator(value, ctx)) {\n        failure.explanation = options.message;\n        status = 'not_valid';\n        yield [failure, undefined];\n    }\n    for (let [k, v, s] of struct.entries(value, ctx)) {\n        const ts = run(v, s, {\n            path: k === undefined ? path : [...path, k],\n            branch: k === undefined ? branch : [...branch, v],\n            coerce,\n            mask,\n            message: options.message,\n        });\n        for (const t of ts) {\n            if (t[0]) {\n                status = t[0].refinement != null ? 'not_refined' : 'not_valid';\n                yield [t[0], undefined];\n            }\n            else if (coerce) {\n                v = t[1];\n                if (k === undefined) {\n                    value = v;\n                }\n                else if (value instanceof Map) {\n                    value.set(k, v);\n                }\n                else if (value instanceof Set) {\n                    value.add(v);\n                }\n                else if (isObject(value)) {\n                    if (v !== undefined || k in value)\n                        value[k] = v;\n                }\n            }\n        }\n    }\n    if (status !== 'not_valid') {\n        for (const failure of struct.refiner(value, ctx)) {\n            failure.explanation = options.message;\n            status = 'not_refined';\n            yield [failure, undefined];\n        }\n    }\n    if (status === 'valid') {\n        yield [undefined, value];\n    }\n}\n\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\nclass Struct {\n    constructor(props) {\n        const { type, schema, validator, refiner, coercer = (value) => value, entries = function* () { }, } = props;\n        this.type = type;\n        this.schema = schema;\n        this.entries = entries;\n        this.coercer = coercer;\n        if (validator) {\n            this.validator = (value, context) => {\n                const result = validator(value, context);\n                return toFailures(result, context, this, value);\n            };\n        }\n        else {\n            this.validator = () => [];\n        }\n        if (refiner) {\n            this.refiner = (value, context) => {\n                const result = refiner(value, context);\n                return toFailures(result, context, this, value);\n            };\n        }\n        else {\n            this.refiner = () => [];\n        }\n    }\n    /**\n     * Assert that a value passes the struct's validation, throwing if it doesn't.\n     */\n    assert(value, message) {\n        return assert(value, this, message);\n    }\n    /**\n     * Create a value with the struct's coercion logic, then validate it.\n     */\n    create(value, message) {\n        return create(value, this, message);\n    }\n    /**\n     * Check if a value passes the struct's validation.\n     */\n    is(value) {\n        return is(value, this);\n    }\n    /**\n     * Mask a value, coercing and validating it, but returning only the subset of\n     * properties defined by the struct's schema.\n     */\n    mask(value, message) {\n        return mask(value, this, message);\n    }\n    /**\n     * Validate a value with the struct's validation logic, returning a tuple\n     * representing the result.\n     *\n     * You may optionally pass `true` for the `withCoercion` argument to coerce\n     * the value before attempting to validate it. If you do, the result will\n     * contain the coerced result when successful.\n     */\n    validate(value, options = {}) {\n        return validate(value, this, options);\n    }\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */\nfunction assert(value, struct, message) {\n    const result = validate(value, struct, { message });\n    if (result[0]) {\n        throw result[0];\n    }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */\nfunction create(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */\nfunction mask(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, mask: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\n/**\n * Check if a value passes a struct.\n */\nfunction is(value, struct) {\n    const result = validate(value, struct);\n    return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */\nfunction validate(value, struct, options = {}) {\n    const tuples = run(value, struct, options);\n    const tuple = shiftIterator(tuples);\n    if (tuple[0]) {\n        const error = new StructError(tuple[0], function* () {\n            for (const t of tuples) {\n                if (t[0]) {\n                    yield t[0];\n                }\n            }\n        });\n        return [error, undefined];\n    }\n    else {\n        const v = tuple[1];\n        return [undefined, v];\n    }\n}\n\nfunction assign(...Structs) {\n    const isType = Structs[0].type === 'type';\n    const schemas = Structs.map((s) => s.schema);\n    const schema = Object.assign({}, ...schemas);\n    return isType ? type(schema) : object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */\nfunction define(name, validator) {\n    return new Struct({ type: name, schema: null, validator });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */\nfunction deprecated(struct, log) {\n    return new Struct({\n        ...struct,\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n        validator(value, ctx) {\n            if (value === undefined) {\n                return true;\n            }\n            else {\n                log(value, ctx);\n                return struct.validator(value, ctx);\n            }\n        },\n    });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */\nfunction dynamic(fn) {\n    return new Struct({\n        type: 'dynamic',\n        schema: null,\n        *entries(value, ctx) {\n            const struct = fn(value, ctx);\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.refiner(value, ctx);\n        },\n    });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */\nfunction lazy(fn) {\n    let struct;\n    return new Struct({\n        type: 'lazy',\n        schema: null,\n        *entries(value, ctx) {\n            struct ?? (struct = fn());\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.refiner(value, ctx);\n        },\n    });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */\nfunction omit(struct, keys) {\n    const { schema } = struct;\n    const subschema = { ...schema };\n    for (const key of keys) {\n        delete subschema[key];\n    }\n    switch (struct.type) {\n        case 'type':\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */\nfunction partial(struct) {\n    const schema = struct instanceof Struct ? { ...struct.schema } : { ...struct };\n    for (const key in schema) {\n        schema[key] = optional(schema[key]);\n    }\n    return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */\nfunction pick(struct, keys) {\n    const { schema } = struct;\n    const subschema = {};\n    for (const key of keys) {\n        subschema[key] = schema[key];\n    }\n    return object(subschema);\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */\nfunction struct(name, validator) {\n    console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');\n    return define(name, validator);\n}\n\n/**\n * Ensure that any value passes validation.\n */\nfunction any() {\n    return define('any', () => true);\n}\nfunction array(Element) {\n    return new Struct({\n        type: 'array',\n        schema: Element,\n        *entries(value) {\n            if (Element && Array.isArray(value)) {\n                for (const [i, v] of value.entries()) {\n                    yield [i, v, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array value, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a bigint.\n */\nfunction bigint() {\n    return define('bigint', (value) => {\n        return typeof value === 'bigint';\n    });\n}\n/**\n * Ensure that a value is a boolean.\n */\nfunction boolean() {\n    return define('boolean', (value) => {\n        return typeof value === 'boolean';\n    });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\nfunction date() {\n    return define('date', (value) => {\n        return ((value instanceof Date && !isNaN(value.getTime())) ||\n            `Expected a valid \\`Date\\` object, but received: ${print(value)}`);\n    });\n}\nfunction enums(values) {\n    const schema = {};\n    const description = values.map((v) => print(v)).join();\n    for (const key of values) {\n        schema[key] = key;\n    }\n    return new Struct({\n        type: 'enums',\n        schema,\n        validator(value) {\n            return (values.includes(value) ||\n                `Expected one of \\`${description}\\`, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a function.\n */\nfunction func() {\n    return define('func', (value) => {\n        return (typeof value === 'function' ||\n            `Expected a function, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */\nfunction instance(Class) {\n    return define('instance', (value) => {\n        return (value instanceof Class ||\n            `Expected a \\`${Class.name}\\` instance, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is an integer.\n */\nfunction integer() {\n    return define('integer', (value) => {\n        return ((typeof value === 'number' && !isNaN(value) && Number.isInteger(value)) ||\n            `Expected an integer, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value matches all of a set of types.\n */\nfunction intersection(Structs) {\n    return new Struct({\n        type: 'intersection',\n        schema: null,\n        *entries(value, ctx) {\n            for (const S of Structs) {\n                yield* S.entries(value, ctx);\n            }\n        },\n        *validator(value, ctx) {\n            for (const S of Structs) {\n                yield* S.validator(value, ctx);\n            }\n        },\n        *refiner(value, ctx) {\n            for (const S of Structs) {\n                yield* S.refiner(value, ctx);\n            }\n        },\n    });\n}\nfunction literal(constant) {\n    const description = print(constant);\n    const t = typeof constant;\n    return new Struct({\n        type: 'literal',\n        schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,\n        validator(value) {\n            return (value === constant ||\n                `Expected the literal \\`${description}\\`, but received: ${print(value)}`);\n        },\n    });\n}\nfunction map(Key, Value) {\n    return new Struct({\n        type: 'map',\n        schema: null,\n        *entries(value) {\n            if (Key && Value && value instanceof Map) {\n                for (const [k, v] of value.entries()) {\n                    yield [k, k, Key];\n                    yield [k, v, Value];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Map ? new Map(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Map ||\n                `Expected a \\`Map\\` object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that no value ever passes validation.\n */\nfunction never() {\n    return define('never', () => false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n */\nfunction nullable(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx) => value === null || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === null || struct.refiner(value, ctx),\n    });\n}\n/**\n * Ensure that a value is a number.\n */\nfunction number() {\n    return define('number', (value) => {\n        return ((typeof value === 'number' && !isNaN(value)) ||\n            `Expected a number, but received: ${print(value)}`);\n    });\n}\nfunction object(schema) {\n    const knowns = schema ? Object.keys(schema) : [];\n    const Never = never();\n    return new Struct({\n        type: 'object',\n        schema: schema ? schema : null,\n        *entries(value) {\n            if (schema && isObject(value)) {\n                const unknowns = new Set(Object.keys(value));\n                for (const key of knowns) {\n                    unknowns.delete(key);\n                    yield [key, value[key], schema[key]];\n                }\n                for (const key of unknowns) {\n                    yield [key, value[key], Never];\n                }\n            }\n        },\n        validator(value) {\n            return (isObject(value) || `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return isObject(value) ? { ...value } : value;\n        },\n    });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */\nfunction optional(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx) => value === undefined || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n    });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\nfunction record(Key, Value) {\n    return new Struct({\n        type: 'record',\n        schema: null,\n        *entries(value) {\n            if (isObject(value)) {\n                for (const k in value) {\n                    const v = value[k];\n                    yield [k, k, Key];\n                    yield [k, v, Value];\n                }\n            }\n        },\n        validator(value) {\n            return (isObject(value) || `Expected an object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */\nfunction regexp() {\n    return define('regexp', (value) => {\n        return value instanceof RegExp;\n    });\n}\nfunction set(Element) {\n    return new Struct({\n        type: 'set',\n        schema: null,\n        *entries(value) {\n            if (Element && value instanceof Set) {\n                for (const v of value) {\n                    yield [v, v, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Set ? new Set(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Set ||\n                `Expected a \\`Set\\` object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a string.\n */\nfunction string() {\n    return define('string', (value) => {\n        return (typeof value === 'string' ||\n            `Expected a string, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n */\nfunction tuple(Structs) {\n    const Never = never();\n    return new Struct({\n        type: 'tuple',\n        schema: null,\n        *entries(value) {\n            if (Array.isArray(value)) {\n                const length = Math.max(Structs.length, value.length);\n                for (let i = 0; i < length; i++) {\n                    yield [i, value[i], Structs[i] || Never];\n                }\n            }\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\nfunction type(schema) {\n    const keys = Object.keys(schema);\n    return new Struct({\n        type: 'type',\n        schema,\n        *entries(value) {\n            if (isObject(value)) {\n                for (const k of keys) {\n                    yield [k, value[k], schema[k]];\n                }\n            }\n        },\n        validator(value) {\n            return (isObject(value) || `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return isObject(value) ? { ...value } : value;\n        },\n    });\n}\n/**\n * Ensure that a value matches one of a set of types.\n */\nfunction union(Structs) {\n    const description = Structs.map((s) => s.type).join(' | ');\n    return new Struct({\n        type: 'union',\n        schema: null,\n        coercer(value) {\n            for (const S of Structs) {\n                const [error, coerced] = S.validate(value, { coerce: true });\n                if (!error) {\n                    return coerced;\n                }\n            }\n            return value;\n        },\n        validator(value, ctx) {\n            const failures = [];\n            for (const S of Structs) {\n                const [...tuples] = run(value, S, ctx);\n                const [first] = tuples;\n                if (!first[0]) {\n                    return [];\n                }\n                else {\n                    for (const [failure] of tuples) {\n                        if (failure) {\n                            failures.push(failure);\n                        }\n                    }\n                }\n            }\n            return [\n                `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(value)}`,\n                ...failures,\n            ];\n        },\n    });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\nfunction unknown() {\n    return define('unknown', () => true);\n}\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validationfor example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction coerce(struct, condition, coercer) {\n    return new Struct({\n        ...struct,\n        coercer: (value, ctx) => {\n            return is(value, condition)\n                ? struct.coercer(coercer(value, ctx), ctx)\n                : struct.coercer(value, ctx);\n        },\n    });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction defaulted(struct, fallback, options = {}) {\n    return coerce(struct, unknown(), (x) => {\n        const f = typeof fallback === 'function' ? fallback() : fallback;\n        if (x === undefined) {\n            return f;\n        }\n        if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n            const ret = { ...x };\n            let changed = false;\n            for (const key in f) {\n                if (ret[key] === undefined) {\n                    ret[key] = f[key];\n                    changed = true;\n                }\n            }\n            if (changed) {\n                return ret;\n            }\n        }\n        return x;\n    });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction trimmed(struct) {\n    return coerce(struct, string(), (x) => x.trim());\n}\n\n/**\n * Ensure that a string, array, map, or set is empty.\n */\nfunction empty(struct) {\n    return refine(struct, 'empty', (value) => {\n        const size = getSize(value);\n        return (size === 0 ||\n            `Expected an empty ${struct.type} but received one with a size of \\`${size}\\``);\n    });\n}\nfunction getSize(value) {\n    if (value instanceof Map || value instanceof Set) {\n        return value.size;\n    }\n    else {\n        return value.length;\n    }\n}\n/**\n * Ensure that a number or date is below a threshold.\n */\nfunction max(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'max', (value) => {\n        return exclusive\n            ? value < threshold\n            : value <= threshold ||\n                `Expected a ${struct.type} less than ${exclusive ? '' : 'or equal to '}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */\nfunction min(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'min', (value) => {\n        return exclusive\n            ? value > threshold\n            : value >= threshold ||\n                `Expected a ${struct.type} greater than ${exclusive ? '' : 'or equal to '}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a string, array, map or set is not empty.\n */\nfunction nonempty(struct) {\n    return refine(struct, 'nonempty', (value) => {\n        const size = getSize(value);\n        return (size > 0 || `Expected a nonempty ${struct.type} but received an empty one`);\n    });\n}\n/**\n * Ensure that a string matches a regular expression.\n */\nfunction pattern(struct, regexp) {\n    return refine(struct, 'pattern', (value) => {\n        return (regexp.test(value) ||\n            `Expected a ${struct.type} matching \\`/${regexp.source}/\\` but received \"${value}\"`);\n    });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */\nfunction size(struct, min, max = min) {\n    const expected = `Expected a ${struct.type}`;\n    const of = min === max ? `of \\`${min}\\`` : `between \\`${min}\\` and \\`${max}\\``;\n    return refine(struct, 'size', (value) => {\n        if (typeof value === 'number' || value instanceof Date) {\n            return ((min <= value && value <= max) ||\n                `${expected} ${of} but received \\`${value}\\``);\n        }\n        else if (value instanceof Map || value instanceof Set) {\n            const { size } = value;\n            return ((min <= size && size <= max) ||\n                `${expected} with a size ${of} but received one with a size of \\`${size}\\``);\n        }\n        else {\n            const { length } = value;\n            return ((min <= length && length <= max) ||\n                `${expected} with a length ${of} but received one with a length of \\`${length}\\``);\n        }\n    });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */\nfunction refine(struct, name, refiner) {\n    return new Struct({\n        ...struct,\n        *refiner(value, ctx) {\n            yield* struct.refiner(value, ctx);\n            const result = refiner(value, ctx);\n            const failures = toFailures(result, ctx, struct, value);\n            for (const failure of failures) {\n                yield { ...failure, refinement: name };\n            }\n        },\n    });\n}\n\nexport { Struct, StructError, any, array, assert, assign, bigint, boolean, coerce, create, date, defaulted, define, deprecated, dynamic, empty, enums, func, instance, integer, intersection, is, lazy, literal, map, mask, max, min, never, nonempty, nullable, number, object, omit, optional, partial, pattern, pick, record, refine, regexp, set, size, string, struct, trimmed, tuple, type, union, unknown, validate };\n//# sourceMappingURL=index.mjs.map\n","import {\n  getErrorMessage\n} from \"./chunk-XYGUOY6N.mjs\";\n\n// src/assert.ts\nimport { assert as assertSuperstruct } from \"superstruct\";\nfunction isConstructable(fn) {\n  return Boolean(typeof fn?.prototype?.constructor?.name === \"string\");\n}\nfunction getErrorMessageWithoutTrailingPeriod(error) {\n  return getErrorMessage(error).replace(/\\.$/u, \"\");\n}\nfunction getError(ErrorWrapper, message) {\n  if (isConstructable(ErrorWrapper)) {\n    return new ErrorWrapper({\n      message\n    });\n  }\n  return ErrorWrapper({\n    message\n  });\n}\nvar AssertionError = class extends Error {\n  constructor(options) {\n    super(options.message);\n    this.code = \"ERR_ASSERTION\";\n  }\n};\nfunction assert(value, message = \"Assertion failed.\", ErrorWrapper = AssertionError) {\n  if (!value) {\n    if (message instanceof Error) {\n      throw message;\n    }\n    throw getError(ErrorWrapper, message);\n  }\n}\nfunction assertStruct(value, struct, errorPrefix = \"Assertion failed\", ErrorWrapper = AssertionError) {\n  try {\n    assertSuperstruct(value, struct);\n  } catch (error) {\n    throw getError(\n      ErrorWrapper,\n      `${errorPrefix}: ${getErrorMessageWithoutTrailingPeriod(error)}.`\n    );\n  }\n}\nfunction assertExhaustive(_object) {\n  throw new Error(\n    \"Invalid branch reached. Should be detected during compilation.\"\n  );\n}\n\nexport {\n  AssertionError,\n  assert,\n  assertStruct,\n  assertExhaustive\n};\n//# sourceMappingURL=chunk-74DGVJVE.mjs.map","import {\n  isNullOrUndefined,\n  isObject\n} from \"./chunk-H4YFDLB7.mjs\";\n\n// src/errors.ts\nimport { ErrorWithCause } from \"pony-cause\";\nfunction isError(error) {\n  return error instanceof Error || isObject(error) && error.constructor.name === \"Error\";\n}\nfunction isErrorWithCode(error) {\n  return typeof error === \"object\" && error !== null && \"code\" in error;\n}\nfunction isErrorWithMessage(error) {\n  return typeof error === \"object\" && error !== null && \"message\" in error;\n}\nfunction isErrorWithStack(error) {\n  return typeof error === \"object\" && error !== null && \"stack\" in error;\n}\nfunction getErrorMessage(error) {\n  if (isErrorWithMessage(error) && typeof error.message === \"string\") {\n    return error.message;\n  }\n  if (isNullOrUndefined(error)) {\n    return \"\";\n  }\n  return String(error);\n}\nfunction wrapError(originalError, message) {\n  if (isError(originalError)) {\n    let error;\n    if (Error.length === 2) {\n      error = new Error(message, { cause: originalError });\n    } else {\n      error = new ErrorWithCause(message, { cause: originalError });\n    }\n    if (isErrorWithCode(originalError)) {\n      error.code = originalError.code;\n    }\n    return error;\n  }\n  if (message.length > 0) {\n    return new Error(`${String(originalError)}: ${message}`);\n  }\n  return new Error(String(originalError));\n}\n\nexport {\n  isErrorWithCode,\n  isErrorWithMessage,\n  isErrorWithStack,\n  getErrorMessage,\n  wrapError\n};\n//# sourceMappingURL=chunk-XYGUOY6N.mjs.map","import {\n  assertStruct\n} from \"./chunk-74DGVJVE.mjs\";\nimport {\n  hasProperty\n} from \"./chunk-H4YFDLB7.mjs\";\n\n// src/json.ts\nimport {\n  any,\n  array,\n  boolean,\n  coerce,\n  create,\n  define,\n  integer,\n  is,\n  lazy,\n  literal,\n  nullable,\n  number,\n  object as superstructObject,\n  optional,\n  record,\n  string,\n  union,\n  unknown,\n  Struct\n} from \"superstruct\";\nvar object = (schema) => (\n  // The type is slightly different from a regular object struct, because we\n  // want to make properties with `undefined` in their type optional, but not\n  // `undefined` itself. This means that we need a type cast.\n  superstructObject(schema)\n);\nfunction hasOptional({ path, branch }) {\n  const field = path[path.length - 1];\n  return hasProperty(branch[branch.length - 2], field);\n}\nfunction exactOptional(struct) {\n  return new Struct({\n    ...struct,\n    type: `optional ${struct.type}`,\n    validator: (value, context) => !hasOptional(context) || struct.validator(value, context),\n    refiner: (value, context) => !hasOptional(context) || struct.refiner(value, context)\n  });\n}\nvar finiteNumber = () => define(\"finite number\", (value) => {\n  return is(value, number()) && Number.isFinite(value);\n});\nvar UnsafeJsonStruct = union([\n  literal(null),\n  boolean(),\n  finiteNumber(),\n  string(),\n  array(lazy(() => UnsafeJsonStruct)),\n  record(\n    string(),\n    lazy(() => UnsafeJsonStruct)\n  )\n]);\nvar JsonStruct = coerce(UnsafeJsonStruct, any(), (value) => {\n  assertStruct(value, UnsafeJsonStruct);\n  return JSON.parse(\n    JSON.stringify(value, (propKey, propValue) => {\n      if (propKey === \"__proto__\" || propKey === \"constructor\") {\n        return void 0;\n      }\n      return propValue;\n    })\n  );\n});\nfunction isValidJson(value) {\n  try {\n    getSafeJson(value);\n    return true;\n  } catch {\n    return false;\n  }\n}\nfunction getSafeJson(value) {\n  return create(value, JsonStruct);\n}\nfunction getJsonSize(value) {\n  assertStruct(value, JsonStruct, \"Invalid JSON value\");\n  const json = JSON.stringify(value);\n  return new TextEncoder().encode(json).byteLength;\n}\nvar jsonrpc2 = \"2.0\";\nvar JsonRpcVersionStruct = literal(jsonrpc2);\nvar JsonRpcIdStruct = nullable(union([number(), string()]));\nvar JsonRpcErrorStruct = object({\n  code: integer(),\n  message: string(),\n  data: exactOptional(JsonStruct),\n  stack: exactOptional(string())\n});\nvar JsonRpcParamsStruct = union([record(string(), JsonStruct), array(JsonStruct)]);\nvar JsonRpcRequestStruct = object({\n  id: JsonRpcIdStruct,\n  jsonrpc: JsonRpcVersionStruct,\n  method: string(),\n  params: exactOptional(JsonRpcParamsStruct)\n});\nvar JsonRpcNotificationStruct = object({\n  jsonrpc: JsonRpcVersionStruct,\n  method: string(),\n  params: exactOptional(JsonRpcParamsStruct)\n});\nfunction isJsonRpcNotification(value) {\n  return is(value, JsonRpcNotificationStruct);\n}\nfunction assertIsJsonRpcNotification(value, ErrorWrapper) {\n  assertStruct(\n    value,\n    JsonRpcNotificationStruct,\n    \"Invalid JSON-RPC notification\",\n    ErrorWrapper\n  );\n}\nfunction isJsonRpcRequest(value) {\n  return is(value, JsonRpcRequestStruct);\n}\nfunction assertIsJsonRpcRequest(value, ErrorWrapper) {\n  assertStruct(\n    value,\n    JsonRpcRequestStruct,\n    \"Invalid JSON-RPC request\",\n    ErrorWrapper\n  );\n}\nvar PendingJsonRpcResponseStruct = superstructObject({\n  id: JsonRpcIdStruct,\n  jsonrpc: JsonRpcVersionStruct,\n  result: optional(unknown()),\n  error: optional(JsonRpcErrorStruct)\n});\nvar JsonRpcSuccessStruct = object({\n  id: JsonRpcIdStruct,\n  jsonrpc: JsonRpcVersionStruct,\n  result: JsonStruct\n});\nvar JsonRpcFailureStruct = object({\n  id: JsonRpcIdStruct,\n  jsonrpc: JsonRpcVersionStruct,\n  error: JsonRpcErrorStruct\n});\nvar JsonRpcResponseStruct = union([\n  JsonRpcSuccessStruct,\n  JsonRpcFailureStruct\n]);\nfunction isPendingJsonRpcResponse(response) {\n  return is(response, PendingJsonRpcResponseStruct);\n}\nfunction assertIsPendingJsonRpcResponse(response, ErrorWrapper) {\n  assertStruct(\n    response,\n    PendingJsonRpcResponseStruct,\n    \"Invalid pending JSON-RPC response\",\n    ErrorWrapper\n  );\n}\nfunction isJsonRpcResponse(response) {\n  return is(response, JsonRpcResponseStruct);\n}\nfunction assertIsJsonRpcResponse(value, ErrorWrapper) {\n  assertStruct(\n    value,\n    JsonRpcResponseStruct,\n    \"Invalid JSON-RPC response\",\n    ErrorWrapper\n  );\n}\nfunction isJsonRpcSuccess(value) {\n  return is(value, JsonRpcSuccessStruct);\n}\nfunction assertIsJsonRpcSuccess(value, ErrorWrapper) {\n  assertStruct(\n    value,\n    JsonRpcSuccessStruct,\n    \"Invalid JSON-RPC success response\",\n    ErrorWrapper\n  );\n}\nfunction isJsonRpcFailure(value) {\n  return is(value, JsonRpcFailureStruct);\n}\nfunction assertIsJsonRpcFailure(value, ErrorWrapper) {\n  assertStruct(\n    value,\n    JsonRpcFailureStruct,\n    \"Invalid JSON-RPC failure response\",\n    ErrorWrapper\n  );\n}\nfunction isJsonRpcError(value) {\n  return is(value, JsonRpcErrorStruct);\n}\nfunction assertIsJsonRpcError(value, ErrorWrapper) {\n  assertStruct(\n    value,\n    JsonRpcErrorStruct,\n    \"Invalid JSON-RPC error\",\n    ErrorWrapper\n  );\n}\nfunction getJsonRpcIdValidator(options) {\n  const { permitEmptyString, permitFractions, permitNull } = {\n    permitEmptyString: true,\n    permitFractions: false,\n    permitNull: true,\n    ...options\n  };\n  const isValidJsonRpcId = (id) => {\n    return Boolean(\n      typeof id === \"number\" && (permitFractions || Number.isInteger(id)) || typeof id === \"string\" && (permitEmptyString || id.length > 0) || permitNull && id === null\n    );\n  };\n  return isValidJsonRpcId;\n}\n\nexport {\n  object,\n  exactOptional,\n  UnsafeJsonStruct,\n  JsonStruct,\n  isValidJson,\n  getSafeJson,\n  getJsonSize,\n  jsonrpc2,\n  JsonRpcVersionStruct,\n  JsonRpcIdStruct,\n  JsonRpcErrorStruct,\n  JsonRpcParamsStruct,\n  JsonRpcRequestStruct,\n  JsonRpcNotificationStruct,\n  isJsonRpcNotification,\n  assertIsJsonRpcNotification,\n  isJsonRpcRequest,\n  assertIsJsonRpcRequest,\n  PendingJsonRpcResponseStruct,\n  JsonRpcSuccessStruct,\n  JsonRpcFailureStruct,\n  JsonRpcResponseStruct,\n  isPendingJsonRpcResponse,\n  assertIsPendingJsonRpcResponse,\n  isJsonRpcResponse,\n  assertIsJsonRpcResponse,\n  isJsonRpcSuccess,\n  assertIsJsonRpcSuccess,\n  isJsonRpcFailure,\n  assertIsJsonRpcFailure,\n  isJsonRpcError,\n  assertIsJsonRpcError,\n  getJsonRpcIdValidator\n};\n//# sourceMappingURL=chunk-6C35XQOF.mjs.map","import { hasProperty, isObject, isValidJson } from '@metamask/utils';\nexport const SNAP_ERROR_CODE = -31002;\nexport const SNAP_ERROR_MESSAGE = 'Snap Error';\n/**\n * Get the error message from an unknown error type.\n *\n * - If the error is an object with a `message` property, return the message.\n * - Otherwise, return the error converted to a string.\n *\n * @param error - The error to get the message from.\n * @returns The error message.\n * @internal\n */ export function getErrorMessage(error) {\n    if (isObject(error) && hasProperty(error, 'message') && typeof error.message === 'string') {\n        return error.message;\n    }\n    return String(error);\n}\n/**\n * Get the error stack from an unknown error type.\n *\n * @param error - The error to get the stack from.\n * @returns The error stack, or undefined if the error does not have a valid\n * stack.\n * @internal\n */ export function getErrorStack(error) {\n    if (isObject(error) && hasProperty(error, 'stack') && typeof error.stack === 'string') {\n        return error.stack;\n    }\n    return undefined;\n}\n/**\n * Get the error code from an unknown error type.\n *\n * @param error - The error to get the code from.\n * @returns The error code, or `-32603` if the error does not have a valid code.\n * @internal\n */ export function getErrorCode(error) {\n    if (isObject(error) && hasProperty(error, 'code') && typeof error.code === 'number' && Number.isInteger(error.code)) {\n        return error.code;\n    }\n    return -32603;\n}\n/**\n * Get the error data from an unknown error type.\n *\n * @param error - The error to get the data from.\n * @returns The error data, or an empty object if the error does not have valid\n * data.\n * @internal\n */ export function getErrorData(error) {\n    if (isObject(error) && hasProperty(error, 'data') && typeof error.data === 'object' && error.data !== null && isValidJson(error.data) && !Array.isArray(error.data)) {\n        return error.data;\n    }\n    return {};\n}\n\n//# sourceMappingURL=errors.js.map","import { Struct, define, literal as superstructLiteral, union as superstructUnion } from 'superstruct';\n/**\n * A wrapper of `superstruct`'s `literal` struct that also defines the name of\n * the struct as the literal value.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n * For example, instead of returning an error like:\n *\n * ```\n * Expected the value to satisfy a union of `literal | literal`, but received: \\\"baz\\\"\n * ```\n *\n * This struct will return an error like:\n *\n * ```\n * Expected the value to satisfy a union of `\"foo\" | \"bar\"`, but received: \\\"baz\\\"\n * ```\n *\n * @param value - The literal value.\n * @returns The `superstruct` struct, which validates that the value is equal\n * to the literal value.\n */ export function literal(value) {\n    return define(JSON.stringify(value), superstructLiteral(value).validator);\n}\n/**\n * A wrapper of `superstruct`'s `union` struct that also defines the schema as\n * the union of the schemas of the structs.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n *\n * @param structs - The structs to union.\n * @param structs.\"0\" - The first struct.\n * @param structs.\"1\" - The remaining structs.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */ export function union([head, ...tail]) {\n    const struct = superstructUnion([\n        head,\n        ...tail\n    ]);\n    return new Struct({\n        ...struct,\n        schema: [\n            head,\n            ...tail\n        ]\n    });\n}\n/**\n * Superstruct struct for validating an enum value. This allows using both the\n * enum string values and the enum itself as values.\n *\n * @param constant - The enum to validate against.\n * @returns The superstruct struct.\n */ export function enumValue(constant) {\n    return literal(constant);\n}\n\n//# sourceMappingURL=structs.js.map","function _check_private_redeclaration(obj, privateCollection) {\n    if (privateCollection.has(obj)) {\n        throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n    }\n}\nfunction _class_apply_descriptor_get(receiver, descriptor) {\n    if (descriptor.get) {\n        return descriptor.get.call(receiver);\n    }\n    return descriptor.value;\n}\nfunction _class_apply_descriptor_set(receiver, descriptor, value) {\n    if (descriptor.set) {\n        descriptor.set.call(receiver, value);\n    } else {\n        if (!descriptor.writable) {\n            throw new TypeError(\"attempted to set read only private field\");\n        }\n        descriptor.value = value;\n    }\n}\nfunction _class_extract_field_descriptor(receiver, privateMap, action) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n    }\n    return privateMap.get(receiver);\n}\nfunction _class_private_field_get(receiver, privateMap) {\n    var descriptor = _class_extract_field_descriptor(receiver, privateMap, \"get\");\n    return _class_apply_descriptor_get(receiver, descriptor);\n}\nfunction _class_private_field_init(obj, privateMap, value) {\n    _check_private_redeclaration(obj, privateMap);\n    privateMap.set(obj, value);\n}\nfunction _class_private_field_set(receiver, privateMap, value) {\n    var descriptor = _class_extract_field_descriptor(receiver, privateMap, \"set\");\n    _class_apply_descriptor_set(receiver, descriptor, value);\n    return value;\n}\nimport { getErrorCode, getErrorData, getErrorMessage, SNAP_ERROR_CODE, SNAP_ERROR_MESSAGE } from './internals';\nvar _code = /*#__PURE__*/ new WeakMap(), _message = /*#__PURE__*/ new WeakMap(), _data = /*#__PURE__*/ new WeakMap(), _stack = /*#__PURE__*/ new WeakMap();\n/**\n * A generic error which can be thrown by a Snap, without it causing the Snap to\n * crash.\n */ export class SnapError extends Error {\n    /**\n   * The error name.\n   *\n   * @returns The error name.\n   */ get name() {\n        return 'SnapError';\n    }\n    /**\n   * The error code.\n   *\n   * @returns The error code.\n   */ get code() {\n        return _class_private_field_get(this, _code);\n    }\n    /**\n   * The error message.\n   *\n   * @returns The error message.\n   */ // This line is covered, but Jest doesn't pick it up for some reason.\n    /* istanbul ignore next */ get message() {\n        return _class_private_field_get(this, _message);\n    }\n    /**\n   * Additional data for the error.\n   *\n   * @returns Additional data for the error.\n   */ get data() {\n        return _class_private_field_get(this, _data);\n    }\n    /**\n   * The error stack.\n   *\n   * @returns The error stack.\n   */ // This line is covered, but Jest doesn't pick it up for some reason.\n    /* istanbul ignore next */ get stack() {\n        return _class_private_field_get(this, _stack);\n    }\n    /**\n   * Convert the error to a JSON object.\n   *\n   * @returns The JSON object.\n   */ toJSON() {\n        return {\n            code: SNAP_ERROR_CODE,\n            message: SNAP_ERROR_MESSAGE,\n            data: {\n                cause: {\n                    code: this.code,\n                    message: this.message,\n                    stack: this.stack,\n                    data: this.data\n                }\n            }\n        };\n    }\n    /**\n   * Serialize the error to a JSON object. This is called by\n   * `@metamask/rpc-errors` when serializing the error.\n   *\n   * @returns The JSON object.\n   */ serialize() {\n        return this.toJSON();\n    }\n    /**\n   * Create a new `SnapError`.\n   *\n   * @param error - The error to create the `SnapError` from. If this is a\n   * `string`, it will be used as the error message. If this is an `Error`, its\n   * `message` property will be used as the error message. If this is a\n   * `JsonRpcError`, its `message` property will be used as the error message\n   * and its `code` property will be used as the error code. Otherwise, the\n   * error will be converted to a string and used as the error message.\n   * @param data - Additional data to include in the error. This will be merged\n   * with the error data, if any.\n   */ constructor(error, data = {}){\n        const message = getErrorMessage(error);\n        super(message);\n        _class_private_field_init(this, _code, {\n            writable: true,\n            value: void 0\n        });\n        _class_private_field_init(this, _message, {\n            writable: true,\n            value: void 0\n        });\n        _class_private_field_init(this, _data, {\n            writable: true,\n            value: void 0\n        });\n        _class_private_field_init(this, _stack, {\n            writable: true,\n            value: void 0\n        });\n        _class_private_field_set(this, _message, message);\n        _class_private_field_set(this, _code, getErrorCode(error));\n        _class_private_field_set(this, _data, {\n            ...getErrorData(error),\n            ...data\n        });\n        _class_private_field_set(this, _stack, super.stack);\n    }\n}\n\n//# sourceMappingURL=errors.js.map","export var SeverityLevel;\n(function(SeverityLevel) {\n    SeverityLevel[\"Critical\"] = 'critical';\n})(SeverityLevel || (SeverityLevel = {}));\n\n//# sourceMappingURL=transaction.js.map","export var DialogType;\n(function(DialogType) {\n    DialogType[\"Alert\"] = 'alert';\n    DialogType[\"Confirmation\"] = 'confirmation';\n    DialogType[\"Prompt\"] = 'prompt';\n})(DialogType || (DialogType = {}));\n\n//# sourceMappingURL=dialog.js.map","export var AuxiliaryFileEncoding;\n(function(AuxiliaryFileEncoding) {\n    AuxiliaryFileEncoding[\"Base64\"] = 'base64';\n    AuxiliaryFileEncoding[\"Hex\"] = 'hex';\n    AuxiliaryFileEncoding[\"Utf8\"] = 'utf8';\n})(AuxiliaryFileEncoding || (AuxiliaryFileEncoding = {}));\n\n//# sourceMappingURL=get-file.js.map","export var ManageStateOperation;\n(function(ManageStateOperation) {\n    ManageStateOperation[\"ClearState\"] = 'clear';\n    ManageStateOperation[\"GetState\"] = 'get';\n    ManageStateOperation[\"UpdateState\"] = 'update';\n})(ManageStateOperation || (ManageStateOperation = {}));\n\n//# sourceMappingURL=manage-state.js.map","export var NotificationType;\n(function(NotificationType) {\n    NotificationType[\"InApp\"] = 'inApp';\n    NotificationType[\"Native\"] = 'native';\n})(NotificationType || (NotificationType = {}));\n\n//# sourceMappingURL=notify.js.map","import { assign, object, string, unknown } from 'superstruct';\nexport var NodeType;\n(function(NodeType) {\n    NodeType[\"Copyable\"] = 'copyable';\n    NodeType[\"Divider\"] = 'divider';\n    NodeType[\"Heading\"] = 'heading';\n    NodeType[\"Panel\"] = 'panel';\n    NodeType[\"Spinner\"] = 'spinner';\n    NodeType[// eslint-disable-next-line @typescript-eslint/no-shadow\n    \"Text\"] = 'text';\n    NodeType[\"Image\"] = 'image';\n    NodeType[\"Row\"] = 'row';\n    NodeType[\"Address\"] = 'address';\n})(NodeType || (NodeType = {}));\n/**\n * @internal\n */ export const NodeStruct = object({\n    type: string()\n});\n/**\n * @internal\n */ export const LiteralStruct = assign(NodeStruct, object({\n    value: unknown()\n}));\n\n//# sourceMappingURL=nodes.js.map","import { assertStruct, isPlainObject } from '@metamask/utils';\n/**\n * A function that returns a function to \"build\" a {@link Component}. It infers\n * the type of the component from the given struct, and performs validation on\n * the created component.\n *\n * The returned function can handle the node arguments in two ways:\n * 1. As a single object, with the keys corresponding to the node's properties,\n * excluding the `type` property.\n * 2. As an array of arguments, with the order corresponding to the given keys.\n *\n * @param type - The type of the component to build.\n * @param struct - The struct to use to validate the component.\n * @param keys - The keys of the component to use as arguments to the builder.\n * The order of the keys determines the order of the arguments.\n * @returns A function that builds a component of the given type.\n * @internal\n */ export function createBuilder(type, struct, keys = []) {\n    return (...args)=>{\n        // Node passed as a single object.\n        if (args.length === 1 && isPlainObject(args[0])) {\n            const node = {\n                ...args[0],\n                type\n            };\n            // The user could be passing invalid values to the builder, so we need to\n            // validate them as per the component's struct.\n            assertStruct(node, struct, `Invalid ${type} component`);\n            return node;\n        }\n        // Node passed as an array of arguments.\n        const node = keys.reduce((partialNode, key, index)=>{\n            if (args[index] !== undefined) {\n                return {\n                    ...partialNode,\n                    [key]: args[index]\n                };\n            }\n            return partialNode;\n        }, {\n            type\n        });\n        // The user could be passing invalid values to the builder, so we need to\n        // validate them as per the component's struct.\n        assertStruct(node, struct, `Invalid ${type} component`);\n        return node;\n    };\n}\n\n//# sourceMappingURL=builder.js.map","import { assign, literal, object, pattern, string } from 'superstruct';\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\nexport const AddressStruct = assign(LiteralStruct, object({\n    type: literal(NodeType.Address),\n    value: pattern(string(), /0x[a-fA-F0-9]{40}/u)\n}));\n/**\n * Create an {@link Address} node.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `value` property.\n * @param args.value - The address to be rendered.\n * @returns The address node as an object.\n * @example\n * const node = address({ value: '0x4bbeeb066ed09b7aed07bf39eee0460dfa261520' });\n * const node = address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520');\n */ export const address = createBuilder(NodeType.Address, AddressStruct, [\n    'value'\n]);\n\n//# sourceMappingURL=address.js.map","import { assign, boolean, literal, object, optional, string } from 'superstruct';\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\nexport const CopyableStruct = assign(LiteralStruct, object({\n    type: literal(NodeType.Copyable),\n    value: string(),\n    sensitive: optional(boolean())\n}));\n/**\n * Create a {@link Copyable} component.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `text` property.\n * @param args.value - The text to be copied.\n * @param args.sensitive - Whether the value is sensitive or not. Sensitive\n * values are only displayed to the user after clicking on the component.\n * Defaults to false.\n * @returns A {@link Copyable} component.\n * @example\n * const node = copyable('Hello, world!');\n * const node = copyable({ value: 'Hello, world!' });\n */ export const copyable = createBuilder(NodeType.Copyable, CopyableStruct, [\n    'value',\n    'sensitive'\n]);\n\n//# sourceMappingURL=copyable.js.map","import { assign, literal, object } from 'superstruct';\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\nexport const DividerStruct = assign(NodeStruct, object({\n    type: literal(NodeType.Divider)\n}));\n/**\n * Create a {@link Divider} node.\n *\n * @returns The divider node as object.\n * @example\n * const node = divider();\n */ export const divider = createBuilder(NodeType.Divider, DividerStruct);\n\n//# sourceMappingURL=divider.js.map","import { assign, literal, object, string } from 'superstruct';\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\nexport const HeadingStruct = assign(LiteralStruct, object({\n    type: literal(NodeType.Heading),\n    value: string()\n}));\n/**\n * Create a {@link Heading} node.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `value` property.\n * @param args.value - The heading text.\n * @returns The heading node as object.\n * @example\n * const node = heading({ value: 'Hello, world!' });\n * const node = heading('Hello, world!');\n */ export const heading = createBuilder(NodeType.Heading, HeadingStruct, [\n    'value'\n]);\n\n//# sourceMappingURL=heading.js.map","import isSvg from 'is-svg';\nimport { assign, literal, object, refine, string } from 'superstruct';\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\n/**\n * Get a Struct that validates a string as a valid SVG.\n *\n * @returns A Struct that validates a string as a valid SVG.\n * @internal\n */ export function svg() {\n    return refine(string(), 'SVG', (value)=>{\n        if (!isSvg(value)) {\n            return 'Value is not a valid SVG.';\n        }\n        return true;\n    });\n}\nexport const ImageStruct = assign(NodeStruct, object({\n    type: literal(NodeType.Image),\n    value: svg()\n}));\n/**\n * Create an {@link Image} node.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `value` property.\n * @param args.value - The SVG image to be rendered. Must be a valid SVG string.\n * @returns The image node as object. Other image formats are supported by\n * embedding them as data URLs in the SVG.\n * @example\n * const node = image({ value: '<svg />' });\n * const node = image('<svg />');\n */ export const image = createBuilder(NodeType.Image, ImageStruct, [\n    'value'\n]);\n\n//# sourceMappingURL=image.js.map","import { assign, boolean, literal, object, optional, string } from 'superstruct';\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\nexport const TextStruct = assign(LiteralStruct, object({\n    type: literal(NodeType.Text),\n    value: string(),\n    markdown: optional(boolean())\n}));\n/**\n * Create a {@link Text} node.\n *\n * @param args - The node arguments. This can be either a string\n * and a boolean, or an object with a `value` property\n * and an optional `markdown` property.\n * @param args.value - The text content of the node.\n * @param args.markdown - An optional flag to enable or disable markdown. This\n * is enabled by default.\n * @returns The text node as object.\n * @example\n * const node = text({ value: 'Hello, world!' });\n * const node = text('Hello, world!');\n * const node = text({ value: 'Hello, world!', markdown: false });\n * const node = text('Hello, world!', false);\n */ export const text = createBuilder(NodeType.Text, TextStruct, [\n    'value',\n    'markdown'\n]);\n\n//# sourceMappingURL=text.js.map","import { assign, literal, object, string, optional, union } from 'superstruct';\nimport { enumValue } from '../../internals';\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\nimport { AddressStruct } from './address';\nimport { ImageStruct } from './image';\nimport { TextStruct } from './text';\nexport var RowVariant;\n(function(RowVariant) {\n    RowVariant[\"Default\"] = 'default';\n    RowVariant[\"Critical\"] = 'critical';\n    RowVariant[\"Warning\"] = 'warning';\n})(RowVariant || (RowVariant = {}));\n// A subset of components made available to the row\nconst RowComponentStruct = union([\n    ImageStruct,\n    TextStruct,\n    AddressStruct\n]);\nexport const RowStruct = assign(LiteralStruct, object({\n    type: literal(NodeType.Row),\n    variant: optional(union([\n        enumValue(RowVariant.Default),\n        enumValue(RowVariant.Critical),\n        enumValue(RowVariant.Warning)\n    ])),\n    label: string(),\n    value: RowComponentStruct\n}));\n/**\n * Create a {@link Row} node.\n *\n * @param args - The node arguments. This can either be a string, a component and an optional variant or an object\n * with the properties: `label`, `value` and `variant`.\n * @param args.label - The label for the row.\n * @param args.value - Another component, is currently limited to `image`, `text` and `address`.\n * @param args.variant - An optional variant, either `default`, `warning` or `critical`.\n * @returns The row node as an object.\n * @example\n * const node = row({ label: 'Address', value: address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520') });\n * const node = row({ label: 'Address', value: address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520'), variant: RowVariant.Warning });\n * const node = row('Address', address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520'));\n * const node = row('Address', address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520'), RowVariant.Warning);\n */ export const row = createBuilder(NodeType.Row, RowStruct, [\n    'label',\n    'value',\n    'variant'\n]);\n\n//# sourceMappingURL=row.js.map","import { assign, literal, object } from 'superstruct';\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\nexport const SpinnerStruct = assign(NodeStruct, object({\n    type: literal(NodeType.Spinner)\n}));\n/**\n * Create a {@link Spinner} node.\n *\n * @returns The spinner node as object.\n * @example\n * const node = spinner();\n */ export const spinner = createBuilder(NodeType.Spinner, SpinnerStruct);\n\n//# sourceMappingURL=spinner.js.map","import { array, assign, lazy, literal, object, union } from 'superstruct';\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\nimport { AddressStruct } from './address';\nimport { CopyableStruct } from './copyable';\nimport { DividerStruct } from './divider';\nimport { HeadingStruct } from './heading';\nimport { ImageStruct } from './image';\nimport { RowStruct } from './row';\nimport { SpinnerStruct } from './spinner';\nimport { TextStruct } from './text';\n/**\n * @internal\n */ export const ParentStruct = assign(NodeStruct, object({\n    // This node references itself indirectly, so we need to use `lazy()`.\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    children: array(lazy(()=>ComponentStruct))\n}));\n/**\n * @internal\n */ export const PanelStruct = assign(ParentStruct, object({\n    type: literal(NodeType.Panel)\n}));\n/**\n * Create a {@link Panel} node.\n *\n * @param args - The node arguments. This can be either an array of children, or\n * an object with a `children` property.\n * @param args.children - The child nodes of the panel. This can be any valid\n * {@link Component}.\n * @returns The panel node as object.\n * @example\n * const node = panel({\n *  children: [\n *    heading({ text: 'Hello, world!' }),\n *    text({ text: 'This is a panel.' }),\n *  ],\n * });\n *\n * const node = panel([\n *   heading('Hello, world!'),\n *   text('This is a panel.'),\n * ]);\n */ export const panel = createBuilder(NodeType.Panel, PanelStruct, [\n    'children'\n]);\n// This is defined separately from `Component` to avoid circular dependencies.\nexport const ComponentStruct = union([\n    CopyableStruct,\n    DividerStruct,\n    HeadingStruct,\n    ImageStruct,\n    PanelStruct,\n    SpinnerStruct,\n    TextStruct,\n    RowStruct,\n    AddressStruct\n]);\n\n//# sourceMappingURL=panel.js.map","import { assertStruct } from '@metamask/utils';\nimport { is } from 'superstruct';\nimport { ComponentStruct } from './components';\n/**\n * Check if the given value is a {@link Component}. This performs recursive\n * validation of the component's children (if any).\n *\n * @param value - The value to check.\n * @returns `true` if the value is a {@link Component}, `false` otherwise.\n */ export function isComponent(value) {\n    return is(value, ComponentStruct);\n}\n/**\n * Assert that the given value is a {@link Component}. This performs recursive\n * validation of the component's children (if any).\n *\n * @param value - The value to check.\n * @throws If the value is not a {@link Component}.\n */ export function assertIsComponent(value) {\n    assertStruct(value, ComponentStruct, 'Invalid component');\n}\n\n//# sourceMappingURL=component.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(638);\n"],"names":["validator","__webpack_require__","XMLParser","XMLBuilder","module","exports","XMLValidator","nameStartChar","nameRegexp","regexName","RegExp","isExist","v","isEmptyObject","obj","Object","keys","length","merge","target","a","arrayMode","len","i","getValue","isName","string","match","exec","getAllMatches","regex","matches","allmatches","startIndex","lastIndex","index","push","util","defaultOptions","allowBooleanAttributes","unpairedTags","isWhiteSpace","char","readPI","xmlData","start","tagname","substr","getErrorObject","getLineNumberForPosition","readCommentAndCDATA","angleBracketsCount","validate","options","assign","tags","tagFound","reachedRoot","err","tagStartPos","closingTag","tagName","trim","substring","msg","result","readAttributeStr","attrStr","value","attrStrStart","isValid","validateAttributeString","code","line","tagClosed","otg","pop","openPos","col","indexOf","afterAmp","validateAmpersand","JSON","stringify","map","t","replace","doubleQuote","singleQuote","startChar","validAttrStrRegxp","attrNames","getPositionFromMatch","undefined","attrName","validateAttrName","hasOwnProperty","re","validateNumberAmpersand","count","message","lineNumber","lines","split","buildFromOrderedJs","attributeNamePrefix","attributesGroupName","textNodeName","ignoreAttributes","cdataPropName","format","indentBy","suppressEmptyNode","suppressUnpairedNode","suppressBooleanAttributes","tagValueProcessor","key","attributeValueProcessor","preserveOrder","commentPropName","entities","val","processEntities","stopNodes","oneListGroup","Builder","isAttribute","attrPrefixLen","processTextOrObjNode","indentate","tagEndChar","newLine","object","level","j2x","buildTextValNode","buildObjectNode","repeat","name","startsWith","prototype","build","jObj","Array","isArray","arrayNodeName","call","Date","attr","buildAttrPairStr","newval","replaceEntitiesValue","arrLen","listTagVal","j","item","Ks","L","closeTag","tagEndExp","piClosingChar","textValue","entity","arrToStr","arr","jPath","indentation","xmlStr","isPreviousElementTag","tagObj","propName","newJPath","tagText","isStopNode","attStr","attr_to_str","tempInd","piTextNodeName","newIdentation","tagStart","tagValue","endsWith","includes","attrMap","attrVal","lastIndexOf","jArray","readEntityExp","entityName","Error","isComment","isEntity","isElement","isAttlist","isNotation","validateEntityName","hasBody","comment","exp","regx","removeNSPrefix","parseTagValue","parseAttributeValue","trimValues","numberParseOptions","hex","leadingZeros","eNotation","alwaysCreateTextNode","htmlEntities","ignoreDeclaration","ignorePiTags","transformTagName","transformAttributeName","updateTag","attrs","buildOptions","xmlNode","readDocType","toNumber","addExternalEntities","externalEntities","entKeys","ent","lastEntities","parseTextData","dontTrim","hasAttributes","isLeafNode","escapeEntities","parseValue","resolveNameSpace","prefix","charAt","attrsRegx","buildAttributesMap","oldVal","aName","newVal","attrCollection","parseXml","xmlObj","currentNode","textData","closeIndex","findClosingIndex","colonIndex","saveTextToParentTag","lastTagName","propIndex","tagsNodeStack","tagData","readTagExp","childNode","add","tagExp","attrExpPresent","addChild","endIndex","this","docTypeEntities","rawTagName","lastTag","isItStopNode","tagContent","readStopNodeData","child","ampEntity","currentTagName","allNodesExp","stopNodePath","stopNodeExp","str","errMsg","closingIndex","closingChar","attrBoundary","ch","data","tagExpWithClosingIndex","separatorIndex","search","trimStart","openTagCount","shouldParse","constructor","OrderedObjParser","prettify","parse","validationOption","toString","orderedObjParser","orderedResult","addEntity","compress","text","compressedObj","property","newJpath","isLeaf","isLeafTag","assignAttributes","jpath","atrrName","propCount","node","isSvg","input","jsonObject","parser","_","hexRegex","numRegex","Number","parseInt","window","parseFloat","consider","decimalPoint","trimmedStr","skipLike","test","sign","numTrimmedByZeros","numStr","trimZeros","num","onRpcRequest","onCronjob","async","origin","request","method","fetch","getPoolInfo","then","response","snap","params","type","content","_snapssdk","panel","heading","supplyAPY","isIsolated","getNotification","notifications","error","console","log","chunk_H4YFDLB7_isObject","Boolean","hasProperty","objectToCheck","JsonSize2","JsonSize","StructError","TypeError","failure","failures","cached","explanation","rest","path","join","cause","dist_isObject","x","print","toFailure","context","struct","branch","refinement","toFailures","Symbol","iterator","r","run","coerce","mask","ctx","coercer","schema","status","k","s","entries","ts","Map","set","Set","refiner","Struct","props","assert","create","is","dist_is","tuples","tuple","done","next","shiftIterator","dist_assign","Structs","isType","schemas","dist_define","lazy","fn","array","Element","slice","dist_boolean","literal","constant","description","never","number","isNaN","knowns","Never","unknowns","delete","optional","record","Key","Value","union","S","coerced","first","unknown","condition","refine","getErrorMessageWithoutTrailingPeriod","isErrorWithMessage","String","getErrorMessage","getError","ErrorWrapper","AssertionError","chunk_74DGVJVE_assertStruct","errorPrefix","chunk_6C35XQOF_object","hasOptional","field","exactOptional","UnsafeJsonStruct","isFinite","JsonStruct","propKey","propValue","isValidJson","getSafeJson","JsonRpcVersionStruct","JsonRpcIdStruct","nullable","JsonRpcErrorStruct","isInteger","stack","JsonRpcParamsStruct","id","jsonrpc","JsonRpcSuccessStruct","JsonRpcFailureStruct","SNAP_ERROR_CODE","SNAP_ERROR_MESSAGE","errors_getErrorMessage","getErrorStack","getErrorData","structs_literal","structs_union","head","tail","enumValue","_class_extract_field_descriptor","receiver","privateMap","action","has","get","_class_private_field_get","descriptor","_class_apply_descriptor_get","_class_private_field_init","privateCollection","_check_private_redeclaration","_class_private_field_set","writable","_class_apply_descriptor_set","SeverityLevel","DialogType","AuxiliaryFileEncoding","ManageStateOperation","NotificationType","NodeType","_code","WeakMap","_message","_data","_stack","SnapError","toJSON","serialize","getErrorCode","createBuilder","args","proto","getPrototypeOf","isPlainObject","reduce","partialNode","NodeStruct","LiteralStruct","AddressStruct","Address","regexp","source","pattern","address","CopyableStruct","Copyable","sensitive","copyable","DividerStruct","Divider","divider","HeadingStruct","Heading","ImageStruct","Image","is_svg_default","image_image","TextStruct","Text","markdown","text_text","RowVariant","RowComponentStruct","RowStruct","Row","variant","Default","Critical","Warning","label","row","SpinnerStruct","Spinner","spinner","ParentStruct","children","ComponentStruct","PanelStruct","Panel","isComponent","assertIsComponent","__webpack_module_cache__","moduleId","cachedModule","__webpack_modules__","n","getter","__esModule","d","definition","o","defineProperty","enumerable","prop","toStringTag","__webpack_exports__"],"sourceRoot":""}