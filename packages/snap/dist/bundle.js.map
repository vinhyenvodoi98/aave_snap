{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://snap/javascript/node_modules/.pnpm/@metamask+utils@8.3.0/node_modules/@metamask/utils/dist/chunk-H4YFDLB7.mjs","webpack://snap/javascript/node_modules/.pnpm/superstruct@1.0.3/node_modules/superstruct/dist/index.mjs","webpack://snap/javascript/node_modules/.pnpm/@metamask+utils@8.3.0/node_modules/@metamask/utils/dist/chunk-74DGVJVE.mjs","webpack://snap/javascript/node_modules/.pnpm/@metamask+utils@8.3.0/node_modules/@metamask/utils/dist/chunk-XYGUOY6N.mjs","webpack://snap/javascript/node_modules/.pnpm/@metamask+utils@8.3.0/node_modules/@metamask/utils/dist/chunk-6C35XQOF.mjs","webpack://snap/../node_modules/.pnpm/@metamask+snaps-sdk@1.2.0/node_modules/@metamask/snaps-sdk/dist/esm/internals/errors.js","webpack://snap/../node_modules/.pnpm/@metamask+snaps-sdk@1.2.0/node_modules/@metamask/snaps-sdk/dist/esm/internals/structs.js","webpack://snap/../node_modules/.pnpm/@metamask+snaps-sdk@1.2.0/node_modules/@metamask/snaps-sdk/dist/esm/errors.js","webpack://snap/../node_modules/.pnpm/@metamask+snaps-sdk@1.2.0/node_modules/@metamask/snaps-sdk/dist/esm/types/handlers/transaction.js","webpack://snap/../node_modules/.pnpm/@metamask+snaps-sdk@1.2.0/node_modules/@metamask/snaps-sdk/dist/esm/types/methods/dialog.js","webpack://snap/../node_modules/.pnpm/@metamask+snaps-sdk@1.2.0/node_modules/@metamask/snaps-sdk/dist/esm/types/methods/get-file.js","webpack://snap/../node_modules/.pnpm/@metamask+snaps-sdk@1.2.0/node_modules/@metamask/snaps-sdk/dist/esm/types/methods/manage-state.js","webpack://snap/../node_modules/.pnpm/@metamask+snaps-sdk@1.2.0/node_modules/@metamask/snaps-sdk/dist/esm/types/methods/notify.js","webpack://snap/../node_modules/.pnpm/@metamask+snaps-sdk@1.2.0/node_modules/@metamask/snaps-sdk/dist/esm/ui/nodes.js","webpack://snap/../node_modules/.pnpm/@metamask+snaps-sdk@1.2.0/node_modules/@metamask/snaps-sdk/dist/esm/ui/builder.js","webpack://snap/../node_modules/.pnpm/@metamask+snaps-sdk@1.2.0/node_modules/@metamask/snaps-sdk/dist/esm/ui/components/address.js","webpack://snap/../node_modules/.pnpm/@metamask+snaps-sdk@1.2.0/node_modules/@metamask/snaps-sdk/dist/esm/ui/components/copyable.js","webpack://snap/../node_modules/.pnpm/@metamask+snaps-sdk@1.2.0/node_modules/@metamask/snaps-sdk/dist/esm/ui/components/divider.js","webpack://snap/../node_modules/.pnpm/@metamask+snaps-sdk@1.2.0/node_modules/@metamask/snaps-sdk/dist/esm/ui/components/heading.js","webpack://snap/../node_modules/.pnpm/@metamask+snaps-sdk@1.2.0/node_modules/@metamask/snaps-sdk/dist/esm/ui/components/image.js","webpack://snap/../node_modules/.pnpm/@metamask+snaps-sdk@1.2.0/node_modules/@metamask/snaps-sdk/dist/esm/ui/components/text.js","webpack://snap/../node_modules/.pnpm/@metamask+snaps-sdk@1.2.0/node_modules/@metamask/snaps-sdk/dist/esm/ui/components/row.js","webpack://snap/../node_modules/.pnpm/@metamask+snaps-sdk@1.2.0/node_modules/@metamask/snaps-sdk/dist/esm/ui/components/spinner.js","webpack://snap/../node_modules/.pnpm/@metamask+snaps-sdk@1.2.0/node_modules/@metamask/snaps-sdk/dist/esm/ui/components/panel.js","webpack://snap/../node_modules/.pnpm/@metamask+snaps-sdk@1.2.0/node_modules/@metamask/snaps-sdk/dist/esm/ui/component.js","webpack://snap/../node_modules/.pnpm/fast-xml-parser@4.3.3/node_modules/fast-xml-parser/src/fxp.js","webpack://snap/../node_modules/.pnpm/fast-xml-parser@4.3.3/node_modules/fast-xml-parser/src/util.js","webpack://snap/../node_modules/.pnpm/fast-xml-parser@4.3.3/node_modules/fast-xml-parser/src/validator.js","webpack://snap/../node_modules/.pnpm/fast-xml-parser@4.3.3/node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js","webpack://snap/../node_modules/.pnpm/fast-xml-parser@4.3.3/node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js","webpack://snap/../node_modules/.pnpm/fast-xml-parser@4.3.3/node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js","webpack://snap/../node_modules/.pnpm/fast-xml-parser@4.3.3/node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js","webpack://snap/../node_modules/.pnpm/fast-xml-parser@4.3.3/node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js","webpack://snap/../node_modules/.pnpm/fast-xml-parser@4.3.3/node_modules/fast-xml-parser/src/xmlparser/XMLParser.js","webpack://snap/../node_modules/.pnpm/fast-xml-parser@4.3.3/node_modules/fast-xml-parser/src/xmlparser/node2json.js","webpack://snap/../node_modules/.pnpm/fast-xml-parser@4.3.3/node_modules/fast-xml-parser/src/xmlparser/xmlNode.js","webpack://snap/../node_modules/.pnpm/is-svg@4.4.0/node_modules/is-svg/index.js","webpack://snap/../node_modules/.pnpm/strnum@1.0.5/node_modules/strnum/strnum.js","webpack://snap/webpack/bootstrap","webpack://snap/webpack/runtime/compat get default export","webpack://snap/webpack/runtime/define property getters","webpack://snap/webpack/runtime/hasOwnProperty shorthand","webpack://snap/webpack/runtime/make namespace object","webpack://snap/./src/index.ts"],"sourcesContent":["// src/misc.ts\nfunction isNonEmptyArray(value) {\n  return Array.isArray(value) && value.length > 0;\n}\nfunction isNullOrUndefined(value) {\n  return value === null || value === void 0;\n}\nfunction isObject(value) {\n  return Boolean(value) && typeof value === \"object\" && !Array.isArray(value);\n}\nvar hasProperty = (objectToCheck, name) => Object.hasOwnProperty.call(objectToCheck, name);\nfunction getKnownPropertyNames(object) {\n  return Object.getOwnPropertyNames(object);\n}\nvar JsonSize = /* @__PURE__ */ ((JsonSize2) => {\n  JsonSize2[JsonSize2[\"Null\"] = 4] = \"Null\";\n  JsonSize2[JsonSize2[\"Comma\"] = 1] = \"Comma\";\n  JsonSize2[JsonSize2[\"Wrapper\"] = 1] = \"Wrapper\";\n  JsonSize2[JsonSize2[\"True\"] = 4] = \"True\";\n  JsonSize2[JsonSize2[\"False\"] = 5] = \"False\";\n  JsonSize2[JsonSize2[\"Quote\"] = 1] = \"Quote\";\n  JsonSize2[JsonSize2[\"Colon\"] = 1] = \"Colon\";\n  JsonSize2[JsonSize2[\"Date\"] = 24] = \"Date\";\n  return JsonSize2;\n})(JsonSize || {});\nvar ESCAPE_CHARACTERS_REGEXP = /\"|\\\\|\\n|\\r|\\t/gu;\nfunction isPlainObject(value) {\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  try {\n    let proto = value;\n    while (Object.getPrototypeOf(proto) !== null) {\n      proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(value) === proto;\n  } catch (_) {\n    return false;\n  }\n}\nfunction isASCII(character) {\n  return character.charCodeAt(0) <= 127;\n}\nfunction calculateStringSize(value) {\n  const size = value.split(\"\").reduce((total, character) => {\n    if (isASCII(character)) {\n      return total + 1;\n    }\n    return total + 2;\n  }, 0);\n  return size + (value.match(ESCAPE_CHARACTERS_REGEXP) ?? []).length;\n}\nfunction calculateNumberSize(value) {\n  return value.toString().length;\n}\n\nexport {\n  isNonEmptyArray,\n  isNullOrUndefined,\n  isObject,\n  hasProperty,\n  getKnownPropertyNames,\n  JsonSize,\n  ESCAPE_CHARACTERS_REGEXP,\n  isPlainObject,\n  isASCII,\n  calculateStringSize,\n  calculateNumberSize\n};\n//# sourceMappingURL=chunk-H4YFDLB7.mjs.map","/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\nclass StructError extends TypeError {\n    constructor(failure, failures) {\n        let cached;\n        const { message, explanation, ...rest } = failure;\n        const { path } = failure;\n        const msg = path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`;\n        super(explanation ?? msg);\n        if (explanation != null)\n            this.cause = msg;\n        Object.assign(this, rest);\n        this.name = this.constructor.name;\n        this.failures = () => {\n            return (cached ?? (cached = [failure, ...failures()]));\n        };\n    }\n}\n\n/**\n * Check if a value is an iterator.\n */\nfunction isIterable(x) {\n    return isObject(x) && typeof x[Symbol.iterator] === 'function';\n}\n/**\n * Check if a value is a plain object.\n */\nfunction isObject(x) {\n    return typeof x === 'object' && x != null;\n}\n/**\n * Check if a value is a plain object.\n */\nfunction isPlainObject(x) {\n    if (Object.prototype.toString.call(x) !== '[object Object]') {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(x);\n    return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */\nfunction print(value) {\n    if (typeof value === 'symbol') {\n        return value.toString();\n    }\n    return typeof value === 'string' ? JSON.stringify(value) : `${value}`;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\nfunction shiftIterator(input) {\n    const { done, value } = input.next();\n    return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */\nfunction toFailure(result, context, struct, value) {\n    if (result === true) {\n        return;\n    }\n    else if (result === false) {\n        result = {};\n    }\n    else if (typeof result === 'string') {\n        result = { message: result };\n    }\n    const { path, branch } = context;\n    const { type } = struct;\n    const { refinement, message = `Expected a value of type \\`${type}\\`${refinement ? ` with refinement \\`${refinement}\\`` : ''}, but received: \\`${print(value)}\\``, } = result;\n    return {\n        value,\n        type,\n        refinement,\n        key: path[path.length - 1],\n        path,\n        branch,\n        ...result,\n        message,\n    };\n}\n/**\n * Convert a validation result to an iterable of failures.\n */\nfunction* toFailures(result, context, struct, value) {\n    if (!isIterable(result)) {\n        result = [result];\n    }\n    for (const r of result) {\n        const failure = toFailure(r, context, struct, value);\n        if (failure) {\n            yield failure;\n        }\n    }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */\nfunction* run(value, struct, options = {}) {\n    const { path = [], branch = [value], coerce = false, mask = false } = options;\n    const ctx = { path, branch };\n    if (coerce) {\n        value = struct.coercer(value, ctx);\n        if (mask &&\n            struct.type !== 'type' &&\n            isObject(struct.schema) &&\n            isObject(value) &&\n            !Array.isArray(value)) {\n            for (const key in value) {\n                if (struct.schema[key] === undefined) {\n                    delete value[key];\n                }\n            }\n        }\n    }\n    let status = 'valid';\n    for (const failure of struct.validator(value, ctx)) {\n        failure.explanation = options.message;\n        status = 'not_valid';\n        yield [failure, undefined];\n    }\n    for (let [k, v, s] of struct.entries(value, ctx)) {\n        const ts = run(v, s, {\n            path: k === undefined ? path : [...path, k],\n            branch: k === undefined ? branch : [...branch, v],\n            coerce,\n            mask,\n            message: options.message,\n        });\n        for (const t of ts) {\n            if (t[0]) {\n                status = t[0].refinement != null ? 'not_refined' : 'not_valid';\n                yield [t[0], undefined];\n            }\n            else if (coerce) {\n                v = t[1];\n                if (k === undefined) {\n                    value = v;\n                }\n                else if (value instanceof Map) {\n                    value.set(k, v);\n                }\n                else if (value instanceof Set) {\n                    value.add(v);\n                }\n                else if (isObject(value)) {\n                    if (v !== undefined || k in value)\n                        value[k] = v;\n                }\n            }\n        }\n    }\n    if (status !== 'not_valid') {\n        for (const failure of struct.refiner(value, ctx)) {\n            failure.explanation = options.message;\n            status = 'not_refined';\n            yield [failure, undefined];\n        }\n    }\n    if (status === 'valid') {\n        yield [undefined, value];\n    }\n}\n\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\nclass Struct {\n    constructor(props) {\n        const { type, schema, validator, refiner, coercer = (value) => value, entries = function* () { }, } = props;\n        this.type = type;\n        this.schema = schema;\n        this.entries = entries;\n        this.coercer = coercer;\n        if (validator) {\n            this.validator = (value, context) => {\n                const result = validator(value, context);\n                return toFailures(result, context, this, value);\n            };\n        }\n        else {\n            this.validator = () => [];\n        }\n        if (refiner) {\n            this.refiner = (value, context) => {\n                const result = refiner(value, context);\n                return toFailures(result, context, this, value);\n            };\n        }\n        else {\n            this.refiner = () => [];\n        }\n    }\n    /**\n     * Assert that a value passes the struct's validation, throwing if it doesn't.\n     */\n    assert(value, message) {\n        return assert(value, this, message);\n    }\n    /**\n     * Create a value with the struct's coercion logic, then validate it.\n     */\n    create(value, message) {\n        return create(value, this, message);\n    }\n    /**\n     * Check if a value passes the struct's validation.\n     */\n    is(value) {\n        return is(value, this);\n    }\n    /**\n     * Mask a value, coercing and validating it, but returning only the subset of\n     * properties defined by the struct's schema.\n     */\n    mask(value, message) {\n        return mask(value, this, message);\n    }\n    /**\n     * Validate a value with the struct's validation logic, returning a tuple\n     * representing the result.\n     *\n     * You may optionally pass `true` for the `withCoercion` argument to coerce\n     * the value before attempting to validate it. If you do, the result will\n     * contain the coerced result when successful.\n     */\n    validate(value, options = {}) {\n        return validate(value, this, options);\n    }\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */\nfunction assert(value, struct, message) {\n    const result = validate(value, struct, { message });\n    if (result[0]) {\n        throw result[0];\n    }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */\nfunction create(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */\nfunction mask(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, mask: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\n/**\n * Check if a value passes a struct.\n */\nfunction is(value, struct) {\n    const result = validate(value, struct);\n    return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */\nfunction validate(value, struct, options = {}) {\n    const tuples = run(value, struct, options);\n    const tuple = shiftIterator(tuples);\n    if (tuple[0]) {\n        const error = new StructError(tuple[0], function* () {\n            for (const t of tuples) {\n                if (t[0]) {\n                    yield t[0];\n                }\n            }\n        });\n        return [error, undefined];\n    }\n    else {\n        const v = tuple[1];\n        return [undefined, v];\n    }\n}\n\nfunction assign(...Structs) {\n    const isType = Structs[0].type === 'type';\n    const schemas = Structs.map((s) => s.schema);\n    const schema = Object.assign({}, ...schemas);\n    return isType ? type(schema) : object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */\nfunction define(name, validator) {\n    return new Struct({ type: name, schema: null, validator });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */\nfunction deprecated(struct, log) {\n    return new Struct({\n        ...struct,\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n        validator(value, ctx) {\n            if (value === undefined) {\n                return true;\n            }\n            else {\n                log(value, ctx);\n                return struct.validator(value, ctx);\n            }\n        },\n    });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */\nfunction dynamic(fn) {\n    return new Struct({\n        type: 'dynamic',\n        schema: null,\n        *entries(value, ctx) {\n            const struct = fn(value, ctx);\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.refiner(value, ctx);\n        },\n    });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */\nfunction lazy(fn) {\n    let struct;\n    return new Struct({\n        type: 'lazy',\n        schema: null,\n        *entries(value, ctx) {\n            struct ?? (struct = fn());\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.refiner(value, ctx);\n        },\n    });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */\nfunction omit(struct, keys) {\n    const { schema } = struct;\n    const subschema = { ...schema };\n    for (const key of keys) {\n        delete subschema[key];\n    }\n    switch (struct.type) {\n        case 'type':\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */\nfunction partial(struct) {\n    const schema = struct instanceof Struct ? { ...struct.schema } : { ...struct };\n    for (const key in schema) {\n        schema[key] = optional(schema[key]);\n    }\n    return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */\nfunction pick(struct, keys) {\n    const { schema } = struct;\n    const subschema = {};\n    for (const key of keys) {\n        subschema[key] = schema[key];\n    }\n    return object(subschema);\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */\nfunction struct(name, validator) {\n    console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');\n    return define(name, validator);\n}\n\n/**\n * Ensure that any value passes validation.\n */\nfunction any() {\n    return define('any', () => true);\n}\nfunction array(Element) {\n    return new Struct({\n        type: 'array',\n        schema: Element,\n        *entries(value) {\n            if (Element && Array.isArray(value)) {\n                for (const [i, v] of value.entries()) {\n                    yield [i, v, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array value, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a bigint.\n */\nfunction bigint() {\n    return define('bigint', (value) => {\n        return typeof value === 'bigint';\n    });\n}\n/**\n * Ensure that a value is a boolean.\n */\nfunction boolean() {\n    return define('boolean', (value) => {\n        return typeof value === 'boolean';\n    });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\nfunction date() {\n    return define('date', (value) => {\n        return ((value instanceof Date && !isNaN(value.getTime())) ||\n            `Expected a valid \\`Date\\` object, but received: ${print(value)}`);\n    });\n}\nfunction enums(values) {\n    const schema = {};\n    const description = values.map((v) => print(v)).join();\n    for (const key of values) {\n        schema[key] = key;\n    }\n    return new Struct({\n        type: 'enums',\n        schema,\n        validator(value) {\n            return (values.includes(value) ||\n                `Expected one of \\`${description}\\`, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a function.\n */\nfunction func() {\n    return define('func', (value) => {\n        return (typeof value === 'function' ||\n            `Expected a function, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */\nfunction instance(Class) {\n    return define('instance', (value) => {\n        return (value instanceof Class ||\n            `Expected a \\`${Class.name}\\` instance, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is an integer.\n */\nfunction integer() {\n    return define('integer', (value) => {\n        return ((typeof value === 'number' && !isNaN(value) && Number.isInteger(value)) ||\n            `Expected an integer, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value matches all of a set of types.\n */\nfunction intersection(Structs) {\n    return new Struct({\n        type: 'intersection',\n        schema: null,\n        *entries(value, ctx) {\n            for (const S of Structs) {\n                yield* S.entries(value, ctx);\n            }\n        },\n        *validator(value, ctx) {\n            for (const S of Structs) {\n                yield* S.validator(value, ctx);\n            }\n        },\n        *refiner(value, ctx) {\n            for (const S of Structs) {\n                yield* S.refiner(value, ctx);\n            }\n        },\n    });\n}\nfunction literal(constant) {\n    const description = print(constant);\n    const t = typeof constant;\n    return new Struct({\n        type: 'literal',\n        schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,\n        validator(value) {\n            return (value === constant ||\n                `Expected the literal \\`${description}\\`, but received: ${print(value)}`);\n        },\n    });\n}\nfunction map(Key, Value) {\n    return new Struct({\n        type: 'map',\n        schema: null,\n        *entries(value) {\n            if (Key && Value && value instanceof Map) {\n                for (const [k, v] of value.entries()) {\n                    yield [k, k, Key];\n                    yield [k, v, Value];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Map ? new Map(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Map ||\n                `Expected a \\`Map\\` object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that no value ever passes validation.\n */\nfunction never() {\n    return define('never', () => false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n */\nfunction nullable(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx) => value === null || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === null || struct.refiner(value, ctx),\n    });\n}\n/**\n * Ensure that a value is a number.\n */\nfunction number() {\n    return define('number', (value) => {\n        return ((typeof value === 'number' && !isNaN(value)) ||\n            `Expected a number, but received: ${print(value)}`);\n    });\n}\nfunction object(schema) {\n    const knowns = schema ? Object.keys(schema) : [];\n    const Never = never();\n    return new Struct({\n        type: 'object',\n        schema: schema ? schema : null,\n        *entries(value) {\n            if (schema && isObject(value)) {\n                const unknowns = new Set(Object.keys(value));\n                for (const key of knowns) {\n                    unknowns.delete(key);\n                    yield [key, value[key], schema[key]];\n                }\n                for (const key of unknowns) {\n                    yield [key, value[key], Never];\n                }\n            }\n        },\n        validator(value) {\n            return (isObject(value) || `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return isObject(value) ? { ...value } : value;\n        },\n    });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */\nfunction optional(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx) => value === undefined || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n    });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\nfunction record(Key, Value) {\n    return new Struct({\n        type: 'record',\n        schema: null,\n        *entries(value) {\n            if (isObject(value)) {\n                for (const k in value) {\n                    const v = value[k];\n                    yield [k, k, Key];\n                    yield [k, v, Value];\n                }\n            }\n        },\n        validator(value) {\n            return (isObject(value) || `Expected an object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */\nfunction regexp() {\n    return define('regexp', (value) => {\n        return value instanceof RegExp;\n    });\n}\nfunction set(Element) {\n    return new Struct({\n        type: 'set',\n        schema: null,\n        *entries(value) {\n            if (Element && value instanceof Set) {\n                for (const v of value) {\n                    yield [v, v, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Set ? new Set(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Set ||\n                `Expected a \\`Set\\` object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a string.\n */\nfunction string() {\n    return define('string', (value) => {\n        return (typeof value === 'string' ||\n            `Expected a string, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n */\nfunction tuple(Structs) {\n    const Never = never();\n    return new Struct({\n        type: 'tuple',\n        schema: null,\n        *entries(value) {\n            if (Array.isArray(value)) {\n                const length = Math.max(Structs.length, value.length);\n                for (let i = 0; i < length; i++) {\n                    yield [i, value[i], Structs[i] || Never];\n                }\n            }\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\nfunction type(schema) {\n    const keys = Object.keys(schema);\n    return new Struct({\n        type: 'type',\n        schema,\n        *entries(value) {\n            if (isObject(value)) {\n                for (const k of keys) {\n                    yield [k, value[k], schema[k]];\n                }\n            }\n        },\n        validator(value) {\n            return (isObject(value) || `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return isObject(value) ? { ...value } : value;\n        },\n    });\n}\n/**\n * Ensure that a value matches one of a set of types.\n */\nfunction union(Structs) {\n    const description = Structs.map((s) => s.type).join(' | ');\n    return new Struct({\n        type: 'union',\n        schema: null,\n        coercer(value) {\n            for (const S of Structs) {\n                const [error, coerced] = S.validate(value, { coerce: true });\n                if (!error) {\n                    return coerced;\n                }\n            }\n            return value;\n        },\n        validator(value, ctx) {\n            const failures = [];\n            for (const S of Structs) {\n                const [...tuples] = run(value, S, ctx);\n                const [first] = tuples;\n                if (!first[0]) {\n                    return [];\n                }\n                else {\n                    for (const [failure] of tuples) {\n                        if (failure) {\n                            failures.push(failure);\n                        }\n                    }\n                }\n            }\n            return [\n                `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(value)}`,\n                ...failures,\n            ];\n        },\n    });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\nfunction unknown() {\n    return define('unknown', () => true);\n}\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validation—for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction coerce(struct, condition, coercer) {\n    return new Struct({\n        ...struct,\n        coercer: (value, ctx) => {\n            return is(value, condition)\n                ? struct.coercer(coercer(value, ctx), ctx)\n                : struct.coercer(value, ctx);\n        },\n    });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction defaulted(struct, fallback, options = {}) {\n    return coerce(struct, unknown(), (x) => {\n        const f = typeof fallback === 'function' ? fallback() : fallback;\n        if (x === undefined) {\n            return f;\n        }\n        if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n            const ret = { ...x };\n            let changed = false;\n            for (const key in f) {\n                if (ret[key] === undefined) {\n                    ret[key] = f[key];\n                    changed = true;\n                }\n            }\n            if (changed) {\n                return ret;\n            }\n        }\n        return x;\n    });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction trimmed(struct) {\n    return coerce(struct, string(), (x) => x.trim());\n}\n\n/**\n * Ensure that a string, array, map, or set is empty.\n */\nfunction empty(struct) {\n    return refine(struct, 'empty', (value) => {\n        const size = getSize(value);\n        return (size === 0 ||\n            `Expected an empty ${struct.type} but received one with a size of \\`${size}\\``);\n    });\n}\nfunction getSize(value) {\n    if (value instanceof Map || value instanceof Set) {\n        return value.size;\n    }\n    else {\n        return value.length;\n    }\n}\n/**\n * Ensure that a number or date is below a threshold.\n */\nfunction max(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'max', (value) => {\n        return exclusive\n            ? value < threshold\n            : value <= threshold ||\n                `Expected a ${struct.type} less than ${exclusive ? '' : 'or equal to '}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */\nfunction min(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'min', (value) => {\n        return exclusive\n            ? value > threshold\n            : value >= threshold ||\n                `Expected a ${struct.type} greater than ${exclusive ? '' : 'or equal to '}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a string, array, map or set is not empty.\n */\nfunction nonempty(struct) {\n    return refine(struct, 'nonempty', (value) => {\n        const size = getSize(value);\n        return (size > 0 || `Expected a nonempty ${struct.type} but received an empty one`);\n    });\n}\n/**\n * Ensure that a string matches a regular expression.\n */\nfunction pattern(struct, regexp) {\n    return refine(struct, 'pattern', (value) => {\n        return (regexp.test(value) ||\n            `Expected a ${struct.type} matching \\`/${regexp.source}/\\` but received \"${value}\"`);\n    });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */\nfunction size(struct, min, max = min) {\n    const expected = `Expected a ${struct.type}`;\n    const of = min === max ? `of \\`${min}\\`` : `between \\`${min}\\` and \\`${max}\\``;\n    return refine(struct, 'size', (value) => {\n        if (typeof value === 'number' || value instanceof Date) {\n            return ((min <= value && value <= max) ||\n                `${expected} ${of} but received \\`${value}\\``);\n        }\n        else if (value instanceof Map || value instanceof Set) {\n            const { size } = value;\n            return ((min <= size && size <= max) ||\n                `${expected} with a size ${of} but received one with a size of \\`${size}\\``);\n        }\n        else {\n            const { length } = value;\n            return ((min <= length && length <= max) ||\n                `${expected} with a length ${of} but received one with a length of \\`${length}\\``);\n        }\n    });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */\nfunction refine(struct, name, refiner) {\n    return new Struct({\n        ...struct,\n        *refiner(value, ctx) {\n            yield* struct.refiner(value, ctx);\n            const result = refiner(value, ctx);\n            const failures = toFailures(result, ctx, struct, value);\n            for (const failure of failures) {\n                yield { ...failure, refinement: name };\n            }\n        },\n    });\n}\n\nexport { Struct, StructError, any, array, assert, assign, bigint, boolean, coerce, create, date, defaulted, define, deprecated, dynamic, empty, enums, func, instance, integer, intersection, is, lazy, literal, map, mask, max, min, never, nonempty, nullable, number, object, omit, optional, partial, pattern, pick, record, refine, regexp, set, size, string, struct, trimmed, tuple, type, union, unknown, validate };\n//# sourceMappingURL=index.mjs.map\n","import {\n  getErrorMessage\n} from \"./chunk-XYGUOY6N.mjs\";\n\n// src/assert.ts\nimport { assert as assertSuperstruct } from \"superstruct\";\nfunction isConstructable(fn) {\n  return Boolean(typeof fn?.prototype?.constructor?.name === \"string\");\n}\nfunction getErrorMessageWithoutTrailingPeriod(error) {\n  return getErrorMessage(error).replace(/\\.$/u, \"\");\n}\nfunction getError(ErrorWrapper, message) {\n  if (isConstructable(ErrorWrapper)) {\n    return new ErrorWrapper({\n      message\n    });\n  }\n  return ErrorWrapper({\n    message\n  });\n}\nvar AssertionError = class extends Error {\n  constructor(options) {\n    super(options.message);\n    this.code = \"ERR_ASSERTION\";\n  }\n};\nfunction assert(value, message = \"Assertion failed.\", ErrorWrapper = AssertionError) {\n  if (!value) {\n    if (message instanceof Error) {\n      throw message;\n    }\n    throw getError(ErrorWrapper, message);\n  }\n}\nfunction assertStruct(value, struct, errorPrefix = \"Assertion failed\", ErrorWrapper = AssertionError) {\n  try {\n    assertSuperstruct(value, struct);\n  } catch (error) {\n    throw getError(\n      ErrorWrapper,\n      `${errorPrefix}: ${getErrorMessageWithoutTrailingPeriod(error)}.`\n    );\n  }\n}\nfunction assertExhaustive(_object) {\n  throw new Error(\n    \"Invalid branch reached. Should be detected during compilation.\"\n  );\n}\n\nexport {\n  AssertionError,\n  assert,\n  assertStruct,\n  assertExhaustive\n};\n//# sourceMappingURL=chunk-74DGVJVE.mjs.map","import {\n  isNullOrUndefined,\n  isObject\n} from \"./chunk-H4YFDLB7.mjs\";\n\n// src/errors.ts\nimport { ErrorWithCause } from \"pony-cause\";\nfunction isError(error) {\n  return error instanceof Error || isObject(error) && error.constructor.name === \"Error\";\n}\nfunction isErrorWithCode(error) {\n  return typeof error === \"object\" && error !== null && \"code\" in error;\n}\nfunction isErrorWithMessage(error) {\n  return typeof error === \"object\" && error !== null && \"message\" in error;\n}\nfunction isErrorWithStack(error) {\n  return typeof error === \"object\" && error !== null && \"stack\" in error;\n}\nfunction getErrorMessage(error) {\n  if (isErrorWithMessage(error) && typeof error.message === \"string\") {\n    return error.message;\n  }\n  if (isNullOrUndefined(error)) {\n    return \"\";\n  }\n  return String(error);\n}\nfunction wrapError(originalError, message) {\n  if (isError(originalError)) {\n    let error;\n    if (Error.length === 2) {\n      error = new Error(message, { cause: originalError });\n    } else {\n      error = new ErrorWithCause(message, { cause: originalError });\n    }\n    if (isErrorWithCode(originalError)) {\n      error.code = originalError.code;\n    }\n    return error;\n  }\n  if (message.length > 0) {\n    return new Error(`${String(originalError)}: ${message}`);\n  }\n  return new Error(String(originalError));\n}\n\nexport {\n  isErrorWithCode,\n  isErrorWithMessage,\n  isErrorWithStack,\n  getErrorMessage,\n  wrapError\n};\n//# sourceMappingURL=chunk-XYGUOY6N.mjs.map","import {\n  assertStruct\n} from \"./chunk-74DGVJVE.mjs\";\nimport {\n  hasProperty\n} from \"./chunk-H4YFDLB7.mjs\";\n\n// src/json.ts\nimport {\n  any,\n  array,\n  boolean,\n  coerce,\n  create,\n  define,\n  integer,\n  is,\n  lazy,\n  literal,\n  nullable,\n  number,\n  object as superstructObject,\n  optional,\n  record,\n  string,\n  union,\n  unknown,\n  Struct\n} from \"superstruct\";\nvar object = (schema) => (\n  // The type is slightly different from a regular object struct, because we\n  // want to make properties with `undefined` in their type optional, but not\n  // `undefined` itself. This means that we need a type cast.\n  superstructObject(schema)\n);\nfunction hasOptional({ path, branch }) {\n  const field = path[path.length - 1];\n  return hasProperty(branch[branch.length - 2], field);\n}\nfunction exactOptional(struct) {\n  return new Struct({\n    ...struct,\n    type: `optional ${struct.type}`,\n    validator: (value, context) => !hasOptional(context) || struct.validator(value, context),\n    refiner: (value, context) => !hasOptional(context) || struct.refiner(value, context)\n  });\n}\nvar finiteNumber = () => define(\"finite number\", (value) => {\n  return is(value, number()) && Number.isFinite(value);\n});\nvar UnsafeJsonStruct = union([\n  literal(null),\n  boolean(),\n  finiteNumber(),\n  string(),\n  array(lazy(() => UnsafeJsonStruct)),\n  record(\n    string(),\n    lazy(() => UnsafeJsonStruct)\n  )\n]);\nvar JsonStruct = coerce(UnsafeJsonStruct, any(), (value) => {\n  assertStruct(value, UnsafeJsonStruct);\n  return JSON.parse(\n    JSON.stringify(value, (propKey, propValue) => {\n      if (propKey === \"__proto__\" || propKey === \"constructor\") {\n        return void 0;\n      }\n      return propValue;\n    })\n  );\n});\nfunction isValidJson(value) {\n  try {\n    getSafeJson(value);\n    return true;\n  } catch {\n    return false;\n  }\n}\nfunction getSafeJson(value) {\n  return create(value, JsonStruct);\n}\nfunction getJsonSize(value) {\n  assertStruct(value, JsonStruct, \"Invalid JSON value\");\n  const json = JSON.stringify(value);\n  return new TextEncoder().encode(json).byteLength;\n}\nvar jsonrpc2 = \"2.0\";\nvar JsonRpcVersionStruct = literal(jsonrpc2);\nvar JsonRpcIdStruct = nullable(union([number(), string()]));\nvar JsonRpcErrorStruct = object({\n  code: integer(),\n  message: string(),\n  data: exactOptional(JsonStruct),\n  stack: exactOptional(string())\n});\nvar JsonRpcParamsStruct = union([record(string(), JsonStruct), array(JsonStruct)]);\nvar JsonRpcRequestStruct = object({\n  id: JsonRpcIdStruct,\n  jsonrpc: JsonRpcVersionStruct,\n  method: string(),\n  params: exactOptional(JsonRpcParamsStruct)\n});\nvar JsonRpcNotificationStruct = object({\n  jsonrpc: JsonRpcVersionStruct,\n  method: string(),\n  params: exactOptional(JsonRpcParamsStruct)\n});\nfunction isJsonRpcNotification(value) {\n  return is(value, JsonRpcNotificationStruct);\n}\nfunction assertIsJsonRpcNotification(value, ErrorWrapper) {\n  assertStruct(\n    value,\n    JsonRpcNotificationStruct,\n    \"Invalid JSON-RPC notification\",\n    ErrorWrapper\n  );\n}\nfunction isJsonRpcRequest(value) {\n  return is(value, JsonRpcRequestStruct);\n}\nfunction assertIsJsonRpcRequest(value, ErrorWrapper) {\n  assertStruct(\n    value,\n    JsonRpcRequestStruct,\n    \"Invalid JSON-RPC request\",\n    ErrorWrapper\n  );\n}\nvar PendingJsonRpcResponseStruct = superstructObject({\n  id: JsonRpcIdStruct,\n  jsonrpc: JsonRpcVersionStruct,\n  result: optional(unknown()),\n  error: optional(JsonRpcErrorStruct)\n});\nvar JsonRpcSuccessStruct = object({\n  id: JsonRpcIdStruct,\n  jsonrpc: JsonRpcVersionStruct,\n  result: JsonStruct\n});\nvar JsonRpcFailureStruct = object({\n  id: JsonRpcIdStruct,\n  jsonrpc: JsonRpcVersionStruct,\n  error: JsonRpcErrorStruct\n});\nvar JsonRpcResponseStruct = union([\n  JsonRpcSuccessStruct,\n  JsonRpcFailureStruct\n]);\nfunction isPendingJsonRpcResponse(response) {\n  return is(response, PendingJsonRpcResponseStruct);\n}\nfunction assertIsPendingJsonRpcResponse(response, ErrorWrapper) {\n  assertStruct(\n    response,\n    PendingJsonRpcResponseStruct,\n    \"Invalid pending JSON-RPC response\",\n    ErrorWrapper\n  );\n}\nfunction isJsonRpcResponse(response) {\n  return is(response, JsonRpcResponseStruct);\n}\nfunction assertIsJsonRpcResponse(value, ErrorWrapper) {\n  assertStruct(\n    value,\n    JsonRpcResponseStruct,\n    \"Invalid JSON-RPC response\",\n    ErrorWrapper\n  );\n}\nfunction isJsonRpcSuccess(value) {\n  return is(value, JsonRpcSuccessStruct);\n}\nfunction assertIsJsonRpcSuccess(value, ErrorWrapper) {\n  assertStruct(\n    value,\n    JsonRpcSuccessStruct,\n    \"Invalid JSON-RPC success response\",\n    ErrorWrapper\n  );\n}\nfunction isJsonRpcFailure(value) {\n  return is(value, JsonRpcFailureStruct);\n}\nfunction assertIsJsonRpcFailure(value, ErrorWrapper) {\n  assertStruct(\n    value,\n    JsonRpcFailureStruct,\n    \"Invalid JSON-RPC failure response\",\n    ErrorWrapper\n  );\n}\nfunction isJsonRpcError(value) {\n  return is(value, JsonRpcErrorStruct);\n}\nfunction assertIsJsonRpcError(value, ErrorWrapper) {\n  assertStruct(\n    value,\n    JsonRpcErrorStruct,\n    \"Invalid JSON-RPC error\",\n    ErrorWrapper\n  );\n}\nfunction getJsonRpcIdValidator(options) {\n  const { permitEmptyString, permitFractions, permitNull } = {\n    permitEmptyString: true,\n    permitFractions: false,\n    permitNull: true,\n    ...options\n  };\n  const isValidJsonRpcId = (id) => {\n    return Boolean(\n      typeof id === \"number\" && (permitFractions || Number.isInteger(id)) || typeof id === \"string\" && (permitEmptyString || id.length > 0) || permitNull && id === null\n    );\n  };\n  return isValidJsonRpcId;\n}\n\nexport {\n  object,\n  exactOptional,\n  UnsafeJsonStruct,\n  JsonStruct,\n  isValidJson,\n  getSafeJson,\n  getJsonSize,\n  jsonrpc2,\n  JsonRpcVersionStruct,\n  JsonRpcIdStruct,\n  JsonRpcErrorStruct,\n  JsonRpcParamsStruct,\n  JsonRpcRequestStruct,\n  JsonRpcNotificationStruct,\n  isJsonRpcNotification,\n  assertIsJsonRpcNotification,\n  isJsonRpcRequest,\n  assertIsJsonRpcRequest,\n  PendingJsonRpcResponseStruct,\n  JsonRpcSuccessStruct,\n  JsonRpcFailureStruct,\n  JsonRpcResponseStruct,\n  isPendingJsonRpcResponse,\n  assertIsPendingJsonRpcResponse,\n  isJsonRpcResponse,\n  assertIsJsonRpcResponse,\n  isJsonRpcSuccess,\n  assertIsJsonRpcSuccess,\n  isJsonRpcFailure,\n  assertIsJsonRpcFailure,\n  isJsonRpcError,\n  assertIsJsonRpcError,\n  getJsonRpcIdValidator\n};\n//# sourceMappingURL=chunk-6C35XQOF.mjs.map","import { hasProperty, isObject, isValidJson } from '@metamask/utils';\nexport const SNAP_ERROR_CODE = -31002;\nexport const SNAP_ERROR_MESSAGE = 'Snap Error';\n/**\n * Get the error message from an unknown error type.\n *\n * - If the error is an object with a `message` property, return the message.\n * - Otherwise, return the error converted to a string.\n *\n * @param error - The error to get the message from.\n * @returns The error message.\n * @internal\n */ export function getErrorMessage(error) {\n    if (isObject(error) && hasProperty(error, 'message') && typeof error.message === 'string') {\n        return error.message;\n    }\n    return String(error);\n}\n/**\n * Get the error stack from an unknown error type.\n *\n * @param error - The error to get the stack from.\n * @returns The error stack, or undefined if the error does not have a valid\n * stack.\n * @internal\n */ export function getErrorStack(error) {\n    if (isObject(error) && hasProperty(error, 'stack') && typeof error.stack === 'string') {\n        return error.stack;\n    }\n    return undefined;\n}\n/**\n * Get the error code from an unknown error type.\n *\n * @param error - The error to get the code from.\n * @returns The error code, or `-32603` if the error does not have a valid code.\n * @internal\n */ export function getErrorCode(error) {\n    if (isObject(error) && hasProperty(error, 'code') && typeof error.code === 'number' && Number.isInteger(error.code)) {\n        return error.code;\n    }\n    return -32603;\n}\n/**\n * Get the error data from an unknown error type.\n *\n * @param error - The error to get the data from.\n * @returns The error data, or an empty object if the error does not have valid\n * data.\n * @internal\n */ export function getErrorData(error) {\n    if (isObject(error) && hasProperty(error, 'data') && typeof error.data === 'object' && error.data !== null && isValidJson(error.data) && !Array.isArray(error.data)) {\n        return error.data;\n    }\n    return {};\n}\n\n//# sourceMappingURL=errors.js.map","import { Struct, define, literal as superstructLiteral, union as superstructUnion } from 'superstruct';\n/**\n * A wrapper of `superstruct`'s `literal` struct that also defines the name of\n * the struct as the literal value.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n * For example, instead of returning an error like:\n *\n * ```\n * Expected the value to satisfy a union of `literal | literal`, but received: \\\"baz\\\"\n * ```\n *\n * This struct will return an error like:\n *\n * ```\n * Expected the value to satisfy a union of `\"foo\" | \"bar\"`, but received: \\\"baz\\\"\n * ```\n *\n * @param value - The literal value.\n * @returns The `superstruct` struct, which validates that the value is equal\n * to the literal value.\n */ export function literal(value) {\n    return define(JSON.stringify(value), superstructLiteral(value).validator);\n}\n/**\n * A wrapper of `superstruct`'s `union` struct that also defines the schema as\n * the union of the schemas of the structs.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n *\n * @param structs - The structs to union.\n * @param structs.\"0\" - The first struct.\n * @param structs.\"1\" - The remaining structs.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */ export function union([head, ...tail]) {\n    const struct = superstructUnion([\n        head,\n        ...tail\n    ]);\n    return new Struct({\n        ...struct,\n        schema: [\n            head,\n            ...tail\n        ]\n    });\n}\n/**\n * Superstruct struct for validating an enum value. This allows using both the\n * enum string values and the enum itself as values.\n *\n * @param constant - The enum to validate against.\n * @returns The superstruct struct.\n */ export function enumValue(constant) {\n    return literal(constant);\n}\n\n//# sourceMappingURL=structs.js.map","function _check_private_redeclaration(obj, privateCollection) {\n    if (privateCollection.has(obj)) {\n        throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n    }\n}\nfunction _class_apply_descriptor_get(receiver, descriptor) {\n    if (descriptor.get) {\n        return descriptor.get.call(receiver);\n    }\n    return descriptor.value;\n}\nfunction _class_apply_descriptor_set(receiver, descriptor, value) {\n    if (descriptor.set) {\n        descriptor.set.call(receiver, value);\n    } else {\n        if (!descriptor.writable) {\n            throw new TypeError(\"attempted to set read only private field\");\n        }\n        descriptor.value = value;\n    }\n}\nfunction _class_extract_field_descriptor(receiver, privateMap, action) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n    }\n    return privateMap.get(receiver);\n}\nfunction _class_private_field_get(receiver, privateMap) {\n    var descriptor = _class_extract_field_descriptor(receiver, privateMap, \"get\");\n    return _class_apply_descriptor_get(receiver, descriptor);\n}\nfunction _class_private_field_init(obj, privateMap, value) {\n    _check_private_redeclaration(obj, privateMap);\n    privateMap.set(obj, value);\n}\nfunction _class_private_field_set(receiver, privateMap, value) {\n    var descriptor = _class_extract_field_descriptor(receiver, privateMap, \"set\");\n    _class_apply_descriptor_set(receiver, descriptor, value);\n    return value;\n}\nimport { getErrorCode, getErrorData, getErrorMessage, SNAP_ERROR_CODE, SNAP_ERROR_MESSAGE } from './internals';\nvar _code = /*#__PURE__*/ new WeakMap(), _message = /*#__PURE__*/ new WeakMap(), _data = /*#__PURE__*/ new WeakMap(), _stack = /*#__PURE__*/ new WeakMap();\n/**\n * A generic error which can be thrown by a Snap, without it causing the Snap to\n * crash.\n */ export class SnapError extends Error {\n    /**\n   * The error name.\n   *\n   * @returns The error name.\n   */ get name() {\n        return 'SnapError';\n    }\n    /**\n   * The error code.\n   *\n   * @returns The error code.\n   */ get code() {\n        return _class_private_field_get(this, _code);\n    }\n    /**\n   * The error message.\n   *\n   * @returns The error message.\n   */ // This line is covered, but Jest doesn't pick it up for some reason.\n    /* istanbul ignore next */ get message() {\n        return _class_private_field_get(this, _message);\n    }\n    /**\n   * Additional data for the error.\n   *\n   * @returns Additional data for the error.\n   */ get data() {\n        return _class_private_field_get(this, _data);\n    }\n    /**\n   * The error stack.\n   *\n   * @returns The error stack.\n   */ // This line is covered, but Jest doesn't pick it up for some reason.\n    /* istanbul ignore next */ get stack() {\n        return _class_private_field_get(this, _stack);\n    }\n    /**\n   * Convert the error to a JSON object.\n   *\n   * @returns The JSON object.\n   */ toJSON() {\n        return {\n            code: SNAP_ERROR_CODE,\n            message: SNAP_ERROR_MESSAGE,\n            data: {\n                cause: {\n                    code: this.code,\n                    message: this.message,\n                    stack: this.stack,\n                    data: this.data\n                }\n            }\n        };\n    }\n    /**\n   * Serialize the error to a JSON object. This is called by\n   * `@metamask/rpc-errors` when serializing the error.\n   *\n   * @returns The JSON object.\n   */ serialize() {\n        return this.toJSON();\n    }\n    /**\n   * Create a new `SnapError`.\n   *\n   * @param error - The error to create the `SnapError` from. If this is a\n   * `string`, it will be used as the error message. If this is an `Error`, its\n   * `message` property will be used as the error message. If this is a\n   * `JsonRpcError`, its `message` property will be used as the error message\n   * and its `code` property will be used as the error code. Otherwise, the\n   * error will be converted to a string and used as the error message.\n   * @param data - Additional data to include in the error. This will be merged\n   * with the error data, if any.\n   */ constructor(error, data = {}){\n        const message = getErrorMessage(error);\n        super(message);\n        _class_private_field_init(this, _code, {\n            writable: true,\n            value: void 0\n        });\n        _class_private_field_init(this, _message, {\n            writable: true,\n            value: void 0\n        });\n        _class_private_field_init(this, _data, {\n            writable: true,\n            value: void 0\n        });\n        _class_private_field_init(this, _stack, {\n            writable: true,\n            value: void 0\n        });\n        _class_private_field_set(this, _message, message);\n        _class_private_field_set(this, _code, getErrorCode(error));\n        _class_private_field_set(this, _data, {\n            ...getErrorData(error),\n            ...data\n        });\n        _class_private_field_set(this, _stack, super.stack);\n    }\n}\n\n//# sourceMappingURL=errors.js.map","export var SeverityLevel;\n(function(SeverityLevel) {\n    SeverityLevel[\"Critical\"] = 'critical';\n})(SeverityLevel || (SeverityLevel = {}));\n\n//# sourceMappingURL=transaction.js.map","export var DialogType;\n(function(DialogType) {\n    DialogType[\"Alert\"] = 'alert';\n    DialogType[\"Confirmation\"] = 'confirmation';\n    DialogType[\"Prompt\"] = 'prompt';\n})(DialogType || (DialogType = {}));\n\n//# sourceMappingURL=dialog.js.map","export var AuxiliaryFileEncoding;\n(function(AuxiliaryFileEncoding) {\n    AuxiliaryFileEncoding[\"Base64\"] = 'base64';\n    AuxiliaryFileEncoding[\"Hex\"] = 'hex';\n    AuxiliaryFileEncoding[\"Utf8\"] = 'utf8';\n})(AuxiliaryFileEncoding || (AuxiliaryFileEncoding = {}));\n\n//# sourceMappingURL=get-file.js.map","export var ManageStateOperation;\n(function(ManageStateOperation) {\n    ManageStateOperation[\"ClearState\"] = 'clear';\n    ManageStateOperation[\"GetState\"] = 'get';\n    ManageStateOperation[\"UpdateState\"] = 'update';\n})(ManageStateOperation || (ManageStateOperation = {}));\n\n//# sourceMappingURL=manage-state.js.map","export var NotificationType;\n(function(NotificationType) {\n    NotificationType[\"InApp\"] = 'inApp';\n    NotificationType[\"Native\"] = 'native';\n})(NotificationType || (NotificationType = {}));\n\n//# sourceMappingURL=notify.js.map","import { assign, object, string, unknown } from 'superstruct';\nexport var NodeType;\n(function(NodeType) {\n    NodeType[\"Copyable\"] = 'copyable';\n    NodeType[\"Divider\"] = 'divider';\n    NodeType[\"Heading\"] = 'heading';\n    NodeType[\"Panel\"] = 'panel';\n    NodeType[\"Spinner\"] = 'spinner';\n    NodeType[// eslint-disable-next-line @typescript-eslint/no-shadow\n    \"Text\"] = 'text';\n    NodeType[\"Image\"] = 'image';\n    NodeType[\"Row\"] = 'row';\n    NodeType[\"Address\"] = 'address';\n})(NodeType || (NodeType = {}));\n/**\n * @internal\n */ export const NodeStruct = object({\n    type: string()\n});\n/**\n * @internal\n */ export const LiteralStruct = assign(NodeStruct, object({\n    value: unknown()\n}));\n\n//# sourceMappingURL=nodes.js.map","import { assertStruct, isPlainObject } from '@metamask/utils';\n/**\n * A function that returns a function to \"build\" a {@link Component}. It infers\n * the type of the component from the given struct, and performs validation on\n * the created component.\n *\n * The returned function can handle the node arguments in two ways:\n * 1. As a single object, with the keys corresponding to the node's properties,\n * excluding the `type` property.\n * 2. As an array of arguments, with the order corresponding to the given keys.\n *\n * @param type - The type of the component to build.\n * @param struct - The struct to use to validate the component.\n * @param keys - The keys of the component to use as arguments to the builder.\n * The order of the keys determines the order of the arguments.\n * @returns A function that builds a component of the given type.\n * @internal\n */ export function createBuilder(type, struct, keys = []) {\n    return (...args)=>{\n        // Node passed as a single object.\n        if (args.length === 1 && isPlainObject(args[0])) {\n            const node = {\n                ...args[0],\n                type\n            };\n            // The user could be passing invalid values to the builder, so we need to\n            // validate them as per the component's struct.\n            assertStruct(node, struct, `Invalid ${type} component`);\n            return node;\n        }\n        // Node passed as an array of arguments.\n        const node = keys.reduce((partialNode, key, index)=>{\n            if (args[index] !== undefined) {\n                return {\n                    ...partialNode,\n                    [key]: args[index]\n                };\n            }\n            return partialNode;\n        }, {\n            type\n        });\n        // The user could be passing invalid values to the builder, so we need to\n        // validate them as per the component's struct.\n        assertStruct(node, struct, `Invalid ${type} component`);\n        return node;\n    };\n}\n\n//# sourceMappingURL=builder.js.map","import { assign, literal, object, pattern, string } from 'superstruct';\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\nexport const AddressStruct = assign(LiteralStruct, object({\n    type: literal(NodeType.Address),\n    value: pattern(string(), /0x[a-fA-F0-9]{40}/u)\n}));\n/**\n * Create an {@link Address} node.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `value` property.\n * @param args.value - The address to be rendered.\n * @returns The address node as an object.\n * @example\n * const node = address({ value: '0x4bbeeb066ed09b7aed07bf39eee0460dfa261520' });\n * const node = address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520');\n */ export const address = createBuilder(NodeType.Address, AddressStruct, [\n    'value'\n]);\n\n//# sourceMappingURL=address.js.map","import { assign, boolean, literal, object, optional, string } from 'superstruct';\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\nexport const CopyableStruct = assign(LiteralStruct, object({\n    type: literal(NodeType.Copyable),\n    value: string(),\n    sensitive: optional(boolean())\n}));\n/**\n * Create a {@link Copyable} component.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `text` property.\n * @param args.value - The text to be copied.\n * @param args.sensitive - Whether the value is sensitive or not. Sensitive\n * values are only displayed to the user after clicking on the component.\n * Defaults to false.\n * @returns A {@link Copyable} component.\n * @example\n * const node = copyable('Hello, world!');\n * const node = copyable({ value: 'Hello, world!' });\n */ export const copyable = createBuilder(NodeType.Copyable, CopyableStruct, [\n    'value',\n    'sensitive'\n]);\n\n//# sourceMappingURL=copyable.js.map","import { assign, literal, object } from 'superstruct';\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\nexport const DividerStruct = assign(NodeStruct, object({\n    type: literal(NodeType.Divider)\n}));\n/**\n * Create a {@link Divider} node.\n *\n * @returns The divider node as object.\n * @example\n * const node = divider();\n */ export const divider = createBuilder(NodeType.Divider, DividerStruct);\n\n//# sourceMappingURL=divider.js.map","import { assign, literal, object, string } from 'superstruct';\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\nexport const HeadingStruct = assign(LiteralStruct, object({\n    type: literal(NodeType.Heading),\n    value: string()\n}));\n/**\n * Create a {@link Heading} node.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `value` property.\n * @param args.value - The heading text.\n * @returns The heading node as object.\n * @example\n * const node = heading({ value: 'Hello, world!' });\n * const node = heading('Hello, world!');\n */ export const heading = createBuilder(NodeType.Heading, HeadingStruct, [\n    'value'\n]);\n\n//# sourceMappingURL=heading.js.map","import isSvg from 'is-svg';\nimport { assign, literal, object, refine, string } from 'superstruct';\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\n/**\n * Get a Struct that validates a string as a valid SVG.\n *\n * @returns A Struct that validates a string as a valid SVG.\n * @internal\n */ export function svg() {\n    return refine(string(), 'SVG', (value)=>{\n        if (!isSvg(value)) {\n            return 'Value is not a valid SVG.';\n        }\n        return true;\n    });\n}\nexport const ImageStruct = assign(NodeStruct, object({\n    type: literal(NodeType.Image),\n    value: svg()\n}));\n/**\n * Create an {@link Image} node.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `value` property.\n * @param args.value - The SVG image to be rendered. Must be a valid SVG string.\n * @returns The image node as object. Other image formats are supported by\n * embedding them as data URLs in the SVG.\n * @example\n * const node = image({ value: '<svg />' });\n * const node = image('<svg />');\n */ export const image = createBuilder(NodeType.Image, ImageStruct, [\n    'value'\n]);\n\n//# sourceMappingURL=image.js.map","import { assign, boolean, literal, object, optional, string } from 'superstruct';\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\nexport const TextStruct = assign(LiteralStruct, object({\n    type: literal(NodeType.Text),\n    value: string(),\n    markdown: optional(boolean())\n}));\n/**\n * Create a {@link Text} node.\n *\n * @param args - The node arguments. This can be either a string\n * and a boolean, or an object with a `value` property\n * and an optional `markdown` property.\n * @param args.value - The text content of the node.\n * @param args.markdown - An optional flag to enable or disable markdown. This\n * is enabled by default.\n * @returns The text node as object.\n * @example\n * const node = text({ value: 'Hello, world!' });\n * const node = text('Hello, world!');\n * const node = text({ value: 'Hello, world!', markdown: false });\n * const node = text('Hello, world!', false);\n */ export const text = createBuilder(NodeType.Text, TextStruct, [\n    'value',\n    'markdown'\n]);\n\n//# sourceMappingURL=text.js.map","import { assign, literal, object, string, optional, union } from 'superstruct';\nimport { enumValue } from '../../internals';\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\nimport { AddressStruct } from './address';\nimport { ImageStruct } from './image';\nimport { TextStruct } from './text';\nexport var RowVariant;\n(function(RowVariant) {\n    RowVariant[\"Default\"] = 'default';\n    RowVariant[\"Critical\"] = 'critical';\n    RowVariant[\"Warning\"] = 'warning';\n})(RowVariant || (RowVariant = {}));\n// A subset of components made available to the row\nconst RowComponentStruct = union([\n    ImageStruct,\n    TextStruct,\n    AddressStruct\n]);\nexport const RowStruct = assign(LiteralStruct, object({\n    type: literal(NodeType.Row),\n    variant: optional(union([\n        enumValue(RowVariant.Default),\n        enumValue(RowVariant.Critical),\n        enumValue(RowVariant.Warning)\n    ])),\n    label: string(),\n    value: RowComponentStruct\n}));\n/**\n * Create a {@link Row} node.\n *\n * @param args - The node arguments. This can either be a string, a component and an optional variant or an object\n * with the properties: `label`, `value` and `variant`.\n * @param args.label - The label for the row.\n * @param args.value - Another component, is currently limited to `image`, `text` and `address`.\n * @param args.variant - An optional variant, either `default`, `warning` or `critical`.\n * @returns The row node as an object.\n * @example\n * const node = row({ label: 'Address', value: address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520') });\n * const node = row({ label: 'Address', value: address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520'), variant: RowVariant.Warning });\n * const node = row('Address', address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520'));\n * const node = row('Address', address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520'), RowVariant.Warning);\n */ export const row = createBuilder(NodeType.Row, RowStruct, [\n    'label',\n    'value',\n    'variant'\n]);\n\n//# sourceMappingURL=row.js.map","import { assign, literal, object } from 'superstruct';\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\nexport const SpinnerStruct = assign(NodeStruct, object({\n    type: literal(NodeType.Spinner)\n}));\n/**\n * Create a {@link Spinner} node.\n *\n * @returns The spinner node as object.\n * @example\n * const node = spinner();\n */ export const spinner = createBuilder(NodeType.Spinner, SpinnerStruct);\n\n//# sourceMappingURL=spinner.js.map","import { array, assign, lazy, literal, object, union } from 'superstruct';\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\nimport { AddressStruct } from './address';\nimport { CopyableStruct } from './copyable';\nimport { DividerStruct } from './divider';\nimport { HeadingStruct } from './heading';\nimport { ImageStruct } from './image';\nimport { RowStruct } from './row';\nimport { SpinnerStruct } from './spinner';\nimport { TextStruct } from './text';\n/**\n * @internal\n */ export const ParentStruct = assign(NodeStruct, object({\n    // This node references itself indirectly, so we need to use `lazy()`.\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    children: array(lazy(()=>ComponentStruct))\n}));\n/**\n * @internal\n */ export const PanelStruct = assign(ParentStruct, object({\n    type: literal(NodeType.Panel)\n}));\n/**\n * Create a {@link Panel} node.\n *\n * @param args - The node arguments. This can be either an array of children, or\n * an object with a `children` property.\n * @param args.children - The child nodes of the panel. This can be any valid\n * {@link Component}.\n * @returns The panel node as object.\n * @example\n * const node = panel({\n *  children: [\n *    heading({ text: 'Hello, world!' }),\n *    text({ text: 'This is a panel.' }),\n *  ],\n * });\n *\n * const node = panel([\n *   heading('Hello, world!'),\n *   text('This is a panel.'),\n * ]);\n */ export const panel = createBuilder(NodeType.Panel, PanelStruct, [\n    'children'\n]);\n// This is defined separately from `Component` to avoid circular dependencies.\nexport const ComponentStruct = union([\n    CopyableStruct,\n    DividerStruct,\n    HeadingStruct,\n    ImageStruct,\n    PanelStruct,\n    SpinnerStruct,\n    TextStruct,\n    RowStruct,\n    AddressStruct\n]);\n\n//# sourceMappingURL=panel.js.map","import { assertStruct } from '@metamask/utils';\nimport { is } from 'superstruct';\nimport { ComponentStruct } from './components';\n/**\n * Check if the given value is a {@link Component}. This performs recursive\n * validation of the component's children (if any).\n *\n * @param value - The value to check.\n * @returns `true` if the value is a {@link Component}, `false` otherwise.\n */ export function isComponent(value) {\n    return is(value, ComponentStruct);\n}\n/**\n * Assert that the given value is a {@link Component}. This performs recursive\n * validation of the component's children (if any).\n *\n * @param value - The value to check.\n * @throws If the value is not a {@link Component}.\n */ export function assertIsComponent(value) {\n    assertStruct(value, ComponentStruct, 'Invalid component');\n}\n\n//# sourceMappingURL=component.js.map","'use strict';\n\nconst validator = require('./validator');\nconst XMLParser = require('./xmlparser/XMLParser');\nconst XMLBuilder = require('./xmlbuilder/json2xml');\n\nmodule.exports = {\n  XMLParser: XMLParser,\n  XMLValidator: validator,\n  XMLBuilder: XMLBuilder\n}","'use strict';\n\nconst nameStartChar = ':A-Za-z_\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD';\nconst nameChar = nameStartChar + '\\\\-.\\\\d\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040';\nconst nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*'\nconst regexName = new RegExp('^' + nameRegexp + '$');\n\nconst getAllMatches = function(string, regex) {\n  const matches = [];\n  let match = regex.exec(string);\n  while (match) {\n    const allmatches = [];\n    allmatches.startIndex = regex.lastIndex - match[0].length;\n    const len = match.length;\n    for (let index = 0; index < len; index++) {\n      allmatches.push(match[index]);\n    }\n    matches.push(allmatches);\n    match = regex.exec(string);\n  }\n  return matches;\n};\n\nconst isName = function(string) {\n  const match = regexName.exec(string);\n  return !(match === null || typeof match === 'undefined');\n};\n\nexports.isExist = function(v) {\n  return typeof v !== 'undefined';\n};\n\nexports.isEmptyObject = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\n/**\n * Copy all the properties of a into b.\n * @param {*} target\n * @param {*} a\n */\nexports.merge = function(target, a, arrayMode) {\n  if (a) {\n    const keys = Object.keys(a); // will return an array of own properties\n    const len = keys.length; //don't make it inline\n    for (let i = 0; i < len; i++) {\n      if (arrayMode === 'strict') {\n        target[keys[i]] = [ a[keys[i]] ];\n      } else {\n        target[keys[i]] = a[keys[i]];\n      }\n    }\n  }\n};\n/* exports.merge =function (b,a){\n  return Object.assign(b,a);\n} */\n\nexports.getValue = function(v) {\n  if (exports.isExist(v)) {\n    return v;\n  } else {\n    return '';\n  }\n};\n\n// const fakeCall = function(a) {return a;};\n// const fakeCallNoReturn = function() {};\n\nexports.isName = isName;\nexports.getAllMatches = getAllMatches;\nexports.nameRegexp = nameRegexp;\n","'use strict';\n\nconst util = require('./util');\n\nconst defaultOptions = {\n  allowBooleanAttributes: false, //A tag can have attributes without any value\n  unpairedTags: []\n};\n\n//const tagsPattern = new RegExp(\"<\\\\/?([\\\\w:\\\\-_\\.]+)\\\\s*\\/?>\",\"g\");\nexports.validate = function (xmlData, options) {\n  options = Object.assign({}, defaultOptions, options);\n\n  //xmlData = xmlData.replace(/(\\r\\n|\\n|\\r)/gm,\"\");//make it single line\n  //xmlData = xmlData.replace(/(^\\s*<\\?xml.*?\\?>)/g,\"\");//Remove XML starting tag\n  //xmlData = xmlData.replace(/(<!DOCTYPE[\\s\\w\\\"\\.\\/\\-\\:]+(\\[.*\\])*\\s*>)/g,\"\");//Remove DOCTYPE\n  const tags = [];\n  let tagFound = false;\n\n  //indicates that the root tag has been closed (aka. depth 0 has been reached)\n  let reachedRoot = false;\n\n  if (xmlData[0] === '\\ufeff') {\n    // check for byte order mark (BOM)\n    xmlData = xmlData.substr(1);\n  }\n  \n  for (let i = 0; i < xmlData.length; i++) {\n\n    if (xmlData[i] === '<' && xmlData[i+1] === '?') {\n      i+=2;\n      i = readPI(xmlData,i);\n      if (i.err) return i;\n    }else if (xmlData[i] === '<') {\n      //starting of tag\n      //read until you reach to '>' avoiding any '>' in attribute value\n      let tagStartPos = i;\n      i++;\n      \n      if (xmlData[i] === '!') {\n        i = readCommentAndCDATA(xmlData, i);\n        continue;\n      } else {\n        let closingTag = false;\n        if (xmlData[i] === '/') {\n          //closing tag\n          closingTag = true;\n          i++;\n        }\n        //read tagname\n        let tagName = '';\n        for (; i < xmlData.length &&\n          xmlData[i] !== '>' &&\n          xmlData[i] !== ' ' &&\n          xmlData[i] !== '\\t' &&\n          xmlData[i] !== '\\n' &&\n          xmlData[i] !== '\\r'; i++\n        ) {\n          tagName += xmlData[i];\n        }\n        tagName = tagName.trim();\n        //console.log(tagName);\n\n        if (tagName[tagName.length - 1] === '/') {\n          //self closing tag without attributes\n          tagName = tagName.substring(0, tagName.length - 1);\n          //continue;\n          i--;\n        }\n        if (!validateTagName(tagName)) {\n          let msg;\n          if (tagName.trim().length === 0) {\n            msg = \"Invalid space after '<'.\";\n          } else {\n            msg = \"Tag '\"+tagName+\"' is an invalid name.\";\n          }\n          return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));\n        }\n\n        const result = readAttributeStr(xmlData, i);\n        if (result === false) {\n          return getErrorObject('InvalidAttr', \"Attributes for '\"+tagName+\"' have open quote.\", getLineNumberForPosition(xmlData, i));\n        }\n        let attrStr = result.value;\n        i = result.index;\n\n        if (attrStr[attrStr.length - 1] === '/') {\n          //self closing tag\n          const attrStrStart = i - attrStr.length;\n          attrStr = attrStr.substring(0, attrStr.length - 1);\n          const isValid = validateAttributeString(attrStr, options);\n          if (isValid === true) {\n            tagFound = true;\n            //continue; //text may presents after self closing tag\n          } else {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));\n          }\n        } else if (closingTag) {\n          if (!result.tagClosed) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' doesn't have proper closing.\", getLineNumberForPosition(xmlData, i));\n          } else if (attrStr.trim().length > 0) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' can't have attributes or invalid starting.\", getLineNumberForPosition(xmlData, tagStartPos));\n          } else {\n            const otg = tags.pop();\n            if (tagName !== otg.tagName) {\n              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);\n              return getErrorObject('InvalidTag',\n                \"Expected closing tag '\"+otg.tagName+\"' (opened in line \"+openPos.line+\", col \"+openPos.col+\") instead of closing tag '\"+tagName+\"'.\",\n                getLineNumberForPosition(xmlData, tagStartPos));\n            }\n\n            //when there are no more tags, we reached the root level.\n            if (tags.length == 0) {\n              reachedRoot = true;\n            }\n          }\n        } else {\n          const isValid = validateAttributeString(attrStr, options);\n          if (isValid !== true) {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));\n          }\n\n          //if the root level has been reached before ...\n          if (reachedRoot === true) {\n            return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));\n          } else if(options.unpairedTags.indexOf(tagName) !== -1){\n            //don't push into stack\n          } else {\n            tags.push({tagName, tagStartPos});\n          }\n          tagFound = true;\n        }\n\n        //skip tag text value\n        //It may include comments and CDATA value\n        for (i++; i < xmlData.length; i++) {\n          if (xmlData[i] === '<') {\n            if (xmlData[i + 1] === '!') {\n              //comment or CADATA\n              i++;\n              i = readCommentAndCDATA(xmlData, i);\n              continue;\n            } else if (xmlData[i+1] === '?') {\n              i = readPI(xmlData, ++i);\n              if (i.err) return i;\n            } else{\n              break;\n            }\n          } else if (xmlData[i] === '&') {\n            const afterAmp = validateAmpersand(xmlData, i);\n            if (afterAmp == -1)\n              return getErrorObject('InvalidChar', \"char '&' is not expected.\", getLineNumberForPosition(xmlData, i));\n            i = afterAmp;\n          }else{\n            if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {\n              return getErrorObject('InvalidXml', \"Extra text at the end\", getLineNumberForPosition(xmlData, i));\n            }\n          }\n        } //end of reading tag text value\n        if (xmlData[i] === '<') {\n          i--;\n        }\n      }\n    } else {\n      if ( isWhiteSpace(xmlData[i])) {\n        continue;\n      }\n      return getErrorObject('InvalidChar', \"char '\"+xmlData[i]+\"' is not expected.\", getLineNumberForPosition(xmlData, i));\n    }\n  }\n\n  if (!tagFound) {\n    return getErrorObject('InvalidXml', 'Start tag expected.', 1);\n  }else if (tags.length == 1) {\n      return getErrorObject('InvalidTag', \"Unclosed tag '\"+tags[0].tagName+\"'.\", getLineNumberForPosition(xmlData, tags[0].tagStartPos));\n  }else if (tags.length > 0) {\n      return getErrorObject('InvalidXml', \"Invalid '\"+\n          JSON.stringify(tags.map(t => t.tagName), null, 4).replace(/\\r?\\n/g, '')+\n          \"' found.\", {line: 1, col: 1});\n  }\n\n  return true;\n};\n\nfunction isWhiteSpace(char){\n  return char === ' ' || char === '\\t' || char === '\\n'  || char === '\\r';\n}\n/**\n * Read Processing insstructions and skip\n * @param {*} xmlData\n * @param {*} i\n */\nfunction readPI(xmlData, i) {\n  const start = i;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] == '?' || xmlData[i] == ' ') {\n      //tagname\n      const tagname = xmlData.substr(start, i - start);\n      if (i > 5 && tagname === 'xml') {\n        return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));\n      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {\n        //check if valid attribut string\n        i++;\n        break;\n      } else {\n        continue;\n      }\n    }\n  }\n  return i;\n}\n\nfunction readCommentAndCDATA(xmlData, i) {\n  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {\n    //comment\n    for (i += 3; i < xmlData.length; i++) {\n      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  } else if (\n    xmlData.length > i + 8 &&\n    xmlData[i + 1] === 'D' &&\n    xmlData[i + 2] === 'O' &&\n    xmlData[i + 3] === 'C' &&\n    xmlData[i + 4] === 'T' &&\n    xmlData[i + 5] === 'Y' &&\n    xmlData[i + 6] === 'P' &&\n    xmlData[i + 7] === 'E'\n  ) {\n    let angleBracketsCount = 1;\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === '<') {\n        angleBracketsCount++;\n      } else if (xmlData[i] === '>') {\n        angleBracketsCount--;\n        if (angleBracketsCount === 0) {\n          break;\n        }\n      }\n    }\n  } else if (\n    xmlData.length > i + 9 &&\n    xmlData[i + 1] === '[' &&\n    xmlData[i + 2] === 'C' &&\n    xmlData[i + 3] === 'D' &&\n    xmlData[i + 4] === 'A' &&\n    xmlData[i + 5] === 'T' &&\n    xmlData[i + 6] === 'A' &&\n    xmlData[i + 7] === '['\n  ) {\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  }\n\n  return i;\n}\n\nconst doubleQuote = '\"';\nconst singleQuote = \"'\";\n\n/**\n * Keep reading xmlData until '<' is found outside the attribute value.\n * @param {string} xmlData\n * @param {number} i\n */\nfunction readAttributeStr(xmlData, i) {\n  let attrStr = '';\n  let startChar = '';\n  let tagClosed = false;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\n      if (startChar === '') {\n        startChar = xmlData[i];\n      } else if (startChar !== xmlData[i]) {\n        //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa\n      } else {\n        startChar = '';\n      }\n    } else if (xmlData[i] === '>') {\n      if (startChar === '') {\n        tagClosed = true;\n        break;\n      }\n    }\n    attrStr += xmlData[i];\n  }\n  if (startChar !== '') {\n    return false;\n  }\n\n  return {\n    value: attrStr,\n    index: i,\n    tagClosed: tagClosed\n  };\n}\n\n/**\n * Select all the attributes whether valid or invalid.\n */\nconst validAttrStrRegxp = new RegExp('(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*([\\'\"])(([\\\\s\\\\S])*?)\\\\5)?', 'g');\n\n//attr, =\"sd\", a=\"amit's\", a=\"sd\"b=\"saf\", ab  cd=\"\"\n\nfunction validateAttributeString(attrStr, options) {\n  //console.log(\"start:\"+attrStr+\":end\");\n\n  //if(attrStr.trim().length === 0) return true; //empty string\n\n  const matches = util.getAllMatches(attrStr, validAttrStrRegxp);\n  const attrNames = {};\n\n  for (let i = 0; i < matches.length; i++) {\n    if (matches[i][1].length === 0) {\n      //nospace before attribute name: a=\"sd\"b=\"saf\"\n      return getErrorObject('InvalidAttr', \"Attribute '\"+matches[i][2]+\"' has no space in starting.\", getPositionFromMatch(matches[i]))\n    } else if (matches[i][3] !== undefined && matches[i][4] === undefined) {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+matches[i][2]+\"' is without value.\", getPositionFromMatch(matches[i]));\n    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {\n      //independent attribute: ab\n      return getErrorObject('InvalidAttr', \"boolean attribute '\"+matches[i][2]+\"' is not allowed.\", getPositionFromMatch(matches[i]));\n    }\n    /* else if(matches[i][6] === undefined){//attribute without value: ab=\n                    return { err: { code:\"InvalidAttr\",msg:\"attribute \" + matches[i][2] + \" has no value assigned.\"}};\n                } */\n    const attrName = matches[i][2];\n    if (!validateAttrName(attrName)) {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+attrName+\"' is an invalid name.\", getPositionFromMatch(matches[i]));\n    }\n    if (!attrNames.hasOwnProperty(attrName)) {\n      //check for duplicate attribute.\n      attrNames[attrName] = 1;\n    } else {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+attrName+\"' is repeated.\", getPositionFromMatch(matches[i]));\n    }\n  }\n\n  return true;\n}\n\nfunction validateNumberAmpersand(xmlData, i) {\n  let re = /\\d/;\n  if (xmlData[i] === 'x') {\n    i++;\n    re = /[\\da-fA-F]/;\n  }\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === ';')\n      return i;\n    if (!xmlData[i].match(re))\n      break;\n  }\n  return -1;\n}\n\nfunction validateAmpersand(xmlData, i) {\n  // https://www.w3.org/TR/xml/#dt-charref\n  i++;\n  if (xmlData[i] === ';')\n    return -1;\n  if (xmlData[i] === '#') {\n    i++;\n    return validateNumberAmpersand(xmlData, i);\n  }\n  let count = 0;\n  for (; i < xmlData.length; i++, count++) {\n    if (xmlData[i].match(/\\w/) && count < 20)\n      continue;\n    if (xmlData[i] === ';')\n      break;\n    return -1;\n  }\n  return i;\n}\n\nfunction getErrorObject(code, message, lineNumber) {\n  return {\n    err: {\n      code: code,\n      msg: message,\n      line: lineNumber.line || lineNumber,\n      col: lineNumber.col,\n    },\n  };\n}\n\nfunction validateAttrName(attrName) {\n  return util.isName(attrName);\n}\n\n// const startsWithXML = /^xml/i;\n\nfunction validateTagName(tagname) {\n  return util.isName(tagname) /* && !tagname.match(startsWithXML) */;\n}\n\n//this function returns the line number for the character at the given index\nfunction getLineNumberForPosition(xmlData, index) {\n  const lines = xmlData.substring(0, index).split(/\\r?\\n/);\n  return {\n    line: lines.length,\n\n    // column number is last line's length + 1, because column numbering starts at 1:\n    col: lines[lines.length - 1].length + 1\n  };\n}\n\n//this function returns the position of the first character of match within attrStr\nfunction getPositionFromMatch(match) {\n  return match.startIndex + match[1].length;\n}\n","'use strict';\n//parse Empty Node as self closing node\nconst buildFromOrderedJs = require('./orderedJs2Xml');\n\nconst defaultOptions = {\n  attributeNamePrefix: '@_',\n  attributesGroupName: false,\n  textNodeName: '#text',\n  ignoreAttributes: true,\n  cdataPropName: false,\n  format: false,\n  indentBy: '  ',\n  suppressEmptyNode: false,\n  suppressUnpairedNode: true,\n  suppressBooleanAttributes: true,\n  tagValueProcessor: function(key, a) {\n    return a;\n  },\n  attributeValueProcessor: function(attrName, a) {\n    return a;\n  },\n  preserveOrder: false,\n  commentPropName: false,\n  unpairedTags: [],\n  entities: [\n    { regex: new RegExp(\"&\", \"g\"), val: \"&amp;\" },//it must be on top\n    { regex: new RegExp(\">\", \"g\"), val: \"&gt;\" },\n    { regex: new RegExp(\"<\", \"g\"), val: \"&lt;\" },\n    { regex: new RegExp(\"\\'\", \"g\"), val: \"&apos;\" },\n    { regex: new RegExp(\"\\\"\", \"g\"), val: \"&quot;\" }\n  ],\n  processEntities: true,\n  stopNodes: [],\n  // transformTagName: false,\n  // transformAttributeName: false,\n  oneListGroup: false\n};\n\nfunction Builder(options) {\n  this.options = Object.assign({}, defaultOptions, options);\n  if (this.options.ignoreAttributes || this.options.attributesGroupName) {\n    this.isAttribute = function(/*a*/) {\n      return false;\n    };\n  } else {\n    this.attrPrefixLen = this.options.attributeNamePrefix.length;\n    this.isAttribute = isAttribute;\n  }\n\n  this.processTextOrObjNode = processTextOrObjNode\n\n  if (this.options.format) {\n    this.indentate = indentate;\n    this.tagEndChar = '>\\n';\n    this.newLine = '\\n';\n  } else {\n    this.indentate = function() {\n      return '';\n    };\n    this.tagEndChar = '>';\n    this.newLine = '';\n  }\n}\n\nBuilder.prototype.build = function(jObj) {\n  if(this.options.preserveOrder){\n    return buildFromOrderedJs(jObj, this.options);\n  }else {\n    if(Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1){\n      jObj = {\n        [this.options.arrayNodeName] : jObj\n      }\n    }\n    return this.j2x(jObj, 0).val;\n  }\n};\n\nBuilder.prototype.j2x = function(jObj, level) {\n  let attrStr = '';\n  let val = '';\n  for (let key in jObj) {\n    if(!Object.prototype.hasOwnProperty.call(jObj, key)) continue;\n    if (typeof jObj[key] === 'undefined') {\n      // supress undefined node only if it is not an attribute\n      if (this.isAttribute(key)) {\n        val += '';\n      }\n    } else if (jObj[key] === null) {\n      // null attribute should be ignored by the attribute list, but should not cause the tag closing\n      if (this.isAttribute(key)) {\n        val += '';\n      } else if (key[0] === '?') {\n        val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;\n      } else {\n        val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n      }\n      // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n    } else if (jObj[key] instanceof Date) {\n      val += this.buildTextValNode(jObj[key], key, '', level);\n    } else if (typeof jObj[key] !== 'object') {\n      //premitive type\n      const attr = this.isAttribute(key);\n      if (attr) {\n        attrStr += this.buildAttrPairStr(attr, '' + jObj[key]);\n      }else {\n        //tag value\n        if (key === this.options.textNodeName) {\n          let newval = this.options.tagValueProcessor(key, '' + jObj[key]);\n          val += this.replaceEntitiesValue(newval);\n        } else {\n          val += this.buildTextValNode(jObj[key], key, '', level);\n        }\n      }\n    } else if (Array.isArray(jObj[key])) {\n      //repeated nodes\n      const arrLen = jObj[key].length;\n      let listTagVal = \"\";\n      for (let j = 0; j < arrLen; j++) {\n        const item = jObj[key][j];\n        if (typeof item === 'undefined') {\n          // supress undefined node\n        } else if (item === null) {\n          if(key[0] === \"?\") val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;\n          else val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n          // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n        } else if (typeof item === 'object') {\n          if(this.options.oneListGroup ){\n            listTagVal += this.j2x(item, level + 1).val;\n          }else{\n            listTagVal += this.processTextOrObjNode(item, key, level)\n          }\n        } else {\n          listTagVal += this.buildTextValNode(item, key, '', level);\n        }\n      }\n      if(this.options.oneListGroup){\n        listTagVal = this.buildObjectNode(listTagVal, key, '', level);\n      }\n      val += listTagVal;\n    } else {\n      //nested node\n      if (this.options.attributesGroupName && key === this.options.attributesGroupName) {\n        const Ks = Object.keys(jObj[key]);\n        const L = Ks.length;\n        for (let j = 0; j < L; j++) {\n          attrStr += this.buildAttrPairStr(Ks[j], '' + jObj[key][Ks[j]]);\n        }\n      } else {\n        val += this.processTextOrObjNode(jObj[key], key, level)\n      }\n    }\n  }\n  return {attrStr: attrStr, val: val};\n};\n\nBuilder.prototype.buildAttrPairStr = function(attrName, val){\n  val = this.options.attributeValueProcessor(attrName, '' + val);\n  val = this.replaceEntitiesValue(val);\n  if (this.options.suppressBooleanAttributes && val === \"true\") {\n    return ' ' + attrName;\n  } else return ' ' + attrName + '=\"' + val + '\"';\n}\n\nfunction processTextOrObjNode (object, key, level) {\n  const result = this.j2x(object, level + 1);\n  if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {\n    return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);\n  } else {\n    return this.buildObjectNode(result.val, key, result.attrStr, level);\n  }\n}\n\nBuilder.prototype.buildObjectNode = function(val, key, attrStr, level) {\n  if(val === \"\"){\n    if(key[0] === \"?\") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;\n    else {\n      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;\n    }\n  }else{\n\n    let tagEndExp = '</' + key + this.tagEndChar;\n    let piClosingChar = \"\";\n    \n    if(key[0] === \"?\") {\n      piClosingChar = \"?\";\n      tagEndExp = \"\";\n    }\n  \n    // attrStr is an empty string in case the attribute came as undefined or null\n    if ((attrStr || attrStr === '') && val.indexOf('<') === -1) {\n      return ( this.indentate(level) + '<' +  key + attrStr + piClosingChar + '>' + val + tagEndExp );\n    } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {\n      return this.indentate(level) + `<!--${val}-->` + this.newLine;\n    }else {\n      return (\n        this.indentate(level) + '<' + key + attrStr + piClosingChar + this.tagEndChar +\n        val +\n        this.indentate(level) + tagEndExp    );\n    }\n  }\n}\n\nBuilder.prototype.closeTag = function(key){\n  let closeTag = \"\";\n  if(this.options.unpairedTags.indexOf(key) !== -1){ //unpaired\n    if(!this.options.suppressUnpairedNode) closeTag = \"/\"\n  }else if(this.options.suppressEmptyNode){ //empty\n    closeTag = \"/\";\n  }else{\n    closeTag = `></${key}`\n  }\n  return closeTag;\n}\n\nfunction buildEmptyObjNode(val, key, attrStr, level) {\n  if (val !== '') {\n    return this.buildObjectNode(val, key, attrStr, level);\n  } else {\n    if(key[0] === \"?\") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;\n    else {\n      return  this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;\n      // return this.buildTagStr(level,key, attrStr);\n    }\n  }\n}\n\nBuilder.prototype.buildTextValNode = function(val, key, attrStr, level) {\n  if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {\n    return this.indentate(level) + `<![CDATA[${val}]]>` +  this.newLine;\n  }else if (this.options.commentPropName !== false && key === this.options.commentPropName) {\n    return this.indentate(level) + `<!--${val}-->` +  this.newLine;\n  }else if(key[0] === \"?\") {//PI tag\n    return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar; \n  }else{\n    let textValue = this.options.tagValueProcessor(key, val);\n    textValue = this.replaceEntitiesValue(textValue);\n  \n    if( textValue === ''){\n      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;\n    }else{\n      return this.indentate(level) + '<' + key + attrStr + '>' +\n         textValue +\n        '</' + key + this.tagEndChar;\n    }\n  }\n}\n\nBuilder.prototype.replaceEntitiesValue = function(textValue){\n  if(textValue && textValue.length > 0 && this.options.processEntities){\n    for (let i=0; i<this.options.entities.length; i++) {\n      const entity = this.options.entities[i];\n      textValue = textValue.replace(entity.regex, entity.val);\n    }\n  }\n  return textValue;\n}\n\nfunction indentate(level) {\n  return this.options.indentBy.repeat(level);\n}\n\nfunction isAttribute(name /*, options*/) {\n  if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {\n    return name.substr(this.attrPrefixLen);\n  } else {\n    return false;\n  }\n}\n\nmodule.exports = Builder;\n","const EOL = \"\\n\";\n\n/**\n * \n * @param {array} jArray \n * @param {any} options \n * @returns \n */\nfunction toXml(jArray, options) {\n    let indentation = \"\";\n    if (options.format && options.indentBy.length > 0) {\n        indentation = EOL;\n    }\n    return arrToStr(jArray, options, \"\", indentation);\n}\n\nfunction arrToStr(arr, options, jPath, indentation) {\n    let xmlStr = \"\";\n    let isPreviousElementTag = false;\n\n    for (let i = 0; i < arr.length; i++) {\n        const tagObj = arr[i];\n        const tagName = propName(tagObj);\n        if(tagName === undefined) continue;\n\n        let newJPath = \"\";\n        if (jPath.length === 0) newJPath = tagName\n        else newJPath = `${jPath}.${tagName}`;\n\n        if (tagName === options.textNodeName) {\n            let tagText = tagObj[tagName];\n            if (!isStopNode(newJPath, options)) {\n                tagText = options.tagValueProcessor(tagName, tagText);\n                tagText = replaceEntitiesValue(tagText, options);\n            }\n            if (isPreviousElementTag) {\n                xmlStr += indentation;\n            }\n            xmlStr += tagText;\n            isPreviousElementTag = false;\n            continue;\n        } else if (tagName === options.cdataPropName) {\n            if (isPreviousElementTag) {\n                xmlStr += indentation;\n            }\n            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;\n            isPreviousElementTag = false;\n            continue;\n        } else if (tagName === options.commentPropName) {\n            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;\n            isPreviousElementTag = true;\n            continue;\n        } else if (tagName[0] === \"?\") {\n            const attStr = attr_to_str(tagObj[\":@\"], options);\n            const tempInd = tagName === \"?xml\" ? \"\" : indentation;\n            let piTextNodeName = tagObj[tagName][0][options.textNodeName];\n            piTextNodeName = piTextNodeName.length !== 0 ? \" \" + piTextNodeName : \"\"; //remove extra spacing\n            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;\n            isPreviousElementTag = true;\n            continue;\n        }\n        let newIdentation = indentation;\n        if (newIdentation !== \"\") {\n            newIdentation += options.indentBy;\n        }\n        const attStr = attr_to_str(tagObj[\":@\"], options);\n        const tagStart = indentation + `<${tagName}${attStr}`;\n        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);\n        if (options.unpairedTags.indexOf(tagName) !== -1) {\n            if (options.suppressUnpairedNode) xmlStr += tagStart + \">\";\n            else xmlStr += tagStart + \"/>\";\n        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {\n            xmlStr += tagStart + \"/>\";\n        } else if (tagValue && tagValue.endsWith(\">\")) {\n            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;\n        } else {\n            xmlStr += tagStart + \">\";\n            if (tagValue && indentation !== \"\" && (tagValue.includes(\"/>\") || tagValue.includes(\"</\"))) {\n                xmlStr += indentation + options.indentBy + tagValue + indentation;\n            } else {\n                xmlStr += tagValue;\n            }\n            xmlStr += `</${tagName}>`;\n        }\n        isPreviousElementTag = true;\n    }\n\n    return xmlStr;\n}\n\nfunction propName(obj) {\n    const keys = Object.keys(obj);\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        if(!obj.hasOwnProperty(key)) continue;\n        if (key !== \":@\") return key;\n    }\n}\n\nfunction attr_to_str(attrMap, options) {\n    let attrStr = \"\";\n    if (attrMap && !options.ignoreAttributes) {\n        for (let attr in attrMap) {\n            if(!attrMap.hasOwnProperty(attr)) continue;\n            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);\n            attrVal = replaceEntitiesValue(attrVal, options);\n            if (attrVal === true && options.suppressBooleanAttributes) {\n                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;\n            } else {\n                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}=\"${attrVal}\"`;\n            }\n        }\n    }\n    return attrStr;\n}\n\nfunction isStopNode(jPath, options) {\n    jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);\n    let tagName = jPath.substr(jPath.lastIndexOf(\".\") + 1);\n    for (let index in options.stopNodes) {\n        if (options.stopNodes[index] === jPath || options.stopNodes[index] === \"*.\" + tagName) return true;\n    }\n    return false;\n}\n\nfunction replaceEntitiesValue(textValue, options) {\n    if (textValue && textValue.length > 0 && options.processEntities) {\n        for (let i = 0; i < options.entities.length; i++) {\n            const entity = options.entities[i];\n            textValue = textValue.replace(entity.regex, entity.val);\n        }\n    }\n    return textValue;\n}\nmodule.exports = toXml;\n","const util = require('../util');\n\n//TODO: handle comments\nfunction readDocType(xmlData, i){\n    \n    const entities = {};\n    if( xmlData[i + 3] === 'O' &&\n         xmlData[i + 4] === 'C' &&\n         xmlData[i + 5] === 'T' &&\n         xmlData[i + 6] === 'Y' &&\n         xmlData[i + 7] === 'P' &&\n         xmlData[i + 8] === 'E')\n    {    \n        i = i+9;\n        let angleBracketsCount = 1;\n        let hasBody = false, comment = false;\n        let exp = \"\";\n        for(;i<xmlData.length;i++){\n            if (xmlData[i] === '<' && !comment) { //Determine the tag type\n                if( hasBody && isEntity(xmlData, i)){\n                    i += 7; \n                    [entityName, val,i] = readEntityExp(xmlData,i+1);\n                    if(val.indexOf(\"&\") === -1) //Parameter entities are not supported\n                        entities[ validateEntityName(entityName) ] = {\n                            regx : RegExp( `&${entityName};`,\"g\"),\n                            val: val\n                        };\n                }\n                else if( hasBody && isElement(xmlData, i))  i += 8;//Not supported\n                else if( hasBody && isAttlist(xmlData, i))  i += 8;//Not supported\n                else if( hasBody && isNotation(xmlData, i)) i += 9;//Not supported\n                else if( isComment)                         comment = true;\n                else                                        throw new Error(\"Invalid DOCTYPE\");\n\n                angleBracketsCount++;\n                exp = \"\";\n            } else if (xmlData[i] === '>') { //Read tag content\n                if(comment){\n                    if( xmlData[i - 1] === \"-\" && xmlData[i - 2] === \"-\"){\n                        comment = false;\n                        angleBracketsCount--;\n                    }\n                }else{\n                    angleBracketsCount--;\n                }\n                if (angleBracketsCount === 0) {\n                  break;\n                }\n            }else if( xmlData[i] === '['){\n                hasBody = true;\n            }else{\n                exp += xmlData[i];\n            }\n        }\n        if(angleBracketsCount !== 0){\n            throw new Error(`Unclosed DOCTYPE`);\n        }\n    }else{\n        throw new Error(`Invalid Tag instead of DOCTYPE`);\n    }\n    return {entities, i};\n}\n\nfunction readEntityExp(xmlData,i){\n    //External entities are not supported\n    //    <!ENTITY ext SYSTEM \"http://normal-website.com\" >\n\n    //Parameter entities are not supported\n    //    <!ENTITY entityname \"&anotherElement;\">\n\n    //Internal entities are supported\n    //    <!ENTITY entityname \"replacement text\">\n    \n    //read EntityName\n    let entityName = \"\";\n    for (; i < xmlData.length && (xmlData[i] !== \"'\" && xmlData[i] !== '\"' ); i++) {\n        // if(xmlData[i] === \" \") continue;\n        // else \n        entityName += xmlData[i];\n    }\n    entityName = entityName.trim();\n    if(entityName.indexOf(\" \") !== -1) throw new Error(\"External entites are not supported\");\n\n    //read Entity Value\n    const startChar = xmlData[i++];\n    let val = \"\"\n    for (; i < xmlData.length && xmlData[i] !== startChar ; i++) {\n        val += xmlData[i];\n    }\n    return [entityName, val, i];\n}\n\nfunction isComment(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === '-' &&\n    xmlData[i+3] === '-') return true\n    return false\n}\nfunction isEntity(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'E' &&\n    xmlData[i+3] === 'N' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'I' &&\n    xmlData[i+6] === 'T' &&\n    xmlData[i+7] === 'Y') return true\n    return false\n}\nfunction isElement(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'E' &&\n    xmlData[i+3] === 'L' &&\n    xmlData[i+4] === 'E' &&\n    xmlData[i+5] === 'M' &&\n    xmlData[i+6] === 'E' &&\n    xmlData[i+7] === 'N' &&\n    xmlData[i+8] === 'T') return true\n    return false\n}\n\nfunction isAttlist(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'A' &&\n    xmlData[i+3] === 'T' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'L' &&\n    xmlData[i+6] === 'I' &&\n    xmlData[i+7] === 'S' &&\n    xmlData[i+8] === 'T') return true\n    return false\n}\nfunction isNotation(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'N' &&\n    xmlData[i+3] === 'O' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'A' &&\n    xmlData[i+6] === 'T' &&\n    xmlData[i+7] === 'I' &&\n    xmlData[i+8] === 'O' &&\n    xmlData[i+9] === 'N') return true\n    return false\n}\n\nfunction validateEntityName(name){\n    if (util.isName(name))\n\treturn name;\n    else\n        throw new Error(`Invalid entity name ${name}`);\n}\n\nmodule.exports = readDocType;\n","\nconst defaultOptions = {\n    preserveOrder: false,\n    attributeNamePrefix: '@_',\n    attributesGroupName: false,\n    textNodeName: '#text',\n    ignoreAttributes: true,\n    removeNSPrefix: false, // remove NS from tag name or attribute name if true\n    allowBooleanAttributes: false, //a tag can have attributes without any value\n    //ignoreRootElement : false,\n    parseTagValue: true,\n    parseAttributeValue: false,\n    trimValues: true, //Trim string values of tag and attributes\n    cdataPropName: false,\n    numberParseOptions: {\n      hex: true,\n      leadingZeros: true,\n      eNotation: true\n    },\n    tagValueProcessor: function(tagName, val) {\n      return val;\n    },\n    attributeValueProcessor: function(attrName, val) {\n      return val;\n    },\n    stopNodes: [], //nested tags will not be parsed even for errors\n    alwaysCreateTextNode: false,\n    isArray: () => false,\n    commentPropName: false,\n    unpairedTags: [],\n    processEntities: true,\n    htmlEntities: false,\n    ignoreDeclaration: false,\n    ignorePiTags: false,\n    transformTagName: false,\n    transformAttributeName: false,\n    updateTag: function(tagName, jPath, attrs){\n      return tagName\n    },\n    // skipEmptyListItem: false\n};\n   \nconst buildOptions = function(options) {\n    return Object.assign({}, defaultOptions, options);\n};\n\nexports.buildOptions = buildOptions;\nexports.defaultOptions = defaultOptions;","'use strict';\n///@ts-check\n\nconst util = require('../util');\nconst xmlNode = require('./xmlNode');\nconst readDocType = require(\"./DocTypeReader\");\nconst toNumber = require(\"strnum\");\n\n// const regx =\n//   '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)'\n//   .replace(/NAME/g, util.nameRegexp);\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\nclass OrderedObjParser{\n  constructor(options){\n    this.options = options;\n    this.currentNode = null;\n    this.tagsNodeStack = [];\n    this.docTypeEntities = {};\n    this.lastEntities = {\n      \"apos\" : { regex: /&(apos|#39|#x27);/g, val : \"'\"},\n      \"gt\" : { regex: /&(gt|#62|#x3E);/g, val : \">\"},\n      \"lt\" : { regex: /&(lt|#60|#x3C);/g, val : \"<\"},\n      \"quot\" : { regex: /&(quot|#34|#x22);/g, val : \"\\\"\"},\n    };\n    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val : \"&\"};\n    this.htmlEntities = {\n      \"space\": { regex: /&(nbsp|#160);/g, val: \" \" },\n      // \"lt\" : { regex: /&(lt|#60);/g, val: \"<\" },\n      // \"gt\" : { regex: /&(gt|#62);/g, val: \">\" },\n      // \"amp\" : { regex: /&(amp|#38);/g, val: \"&\" },\n      // \"quot\" : { regex: /&(quot|#34);/g, val: \"\\\"\" },\n      // \"apos\" : { regex: /&(apos|#39);/g, val: \"'\" },\n      \"cent\" : { regex: /&(cent|#162);/g, val: \"¢\" },\n      \"pound\" : { regex: /&(pound|#163);/g, val: \"£\" },\n      \"yen\" : { regex: /&(yen|#165);/g, val: \"¥\" },\n      \"euro\" : { regex: /&(euro|#8364);/g, val: \"€\" },\n      \"copyright\" : { regex: /&(copy|#169);/g, val: \"©\" },\n      \"reg\" : { regex: /&(reg|#174);/g, val: \"®\" },\n      \"inr\" : { regex: /&(inr|#8377);/g, val: \"₹\" },\n    };\n    this.addExternalEntities = addExternalEntities;\n    this.parseXml = parseXml;\n    this.parseTextData = parseTextData;\n    this.resolveNameSpace = resolveNameSpace;\n    this.buildAttributesMap = buildAttributesMap;\n    this.isItStopNode = isItStopNode;\n    this.replaceEntitiesValue = replaceEntitiesValue;\n    this.readStopNodeData = readStopNodeData;\n    this.saveTextToParentTag = saveTextToParentTag;\n    this.addChild = addChild;\n  }\n\n}\n\nfunction addExternalEntities(externalEntities){\n  const entKeys = Object.keys(externalEntities);\n  for (let i = 0; i < entKeys.length; i++) {\n    const ent = entKeys[i];\n    this.lastEntities[ent] = {\n       regex: new RegExp(\"&\"+ent+\";\",\"g\"),\n       val : externalEntities[ent]\n    }\n  }\n}\n\n/**\n * @param {string} val\n * @param {string} tagName\n * @param {string} jPath\n * @param {boolean} dontTrim\n * @param {boolean} hasAttributes\n * @param {boolean} isLeafNode\n * @param {boolean} escapeEntities\n */\nfunction parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {\n  if (val !== undefined) {\n    if (this.options.trimValues && !dontTrim) {\n      val = val.trim();\n    }\n    if(val.length > 0){\n      if(!escapeEntities) val = this.replaceEntitiesValue(val);\n      \n      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);\n      if(newval === null || newval === undefined){\n        //don't parse\n        return val;\n      }else if(typeof newval !== typeof val || newval !== val){\n        //overwrite\n        return newval;\n      }else if(this.options.trimValues){\n        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n      }else{\n        const trimmedVal = val.trim();\n        if(trimmedVal === val){\n          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n        }else{\n          return val;\n        }\n      }\n    }\n  }\n}\n\nfunction resolveNameSpace(tagname) {\n  if (this.options.removeNSPrefix) {\n    const tags = tagname.split(':');\n    const prefix = tagname.charAt(0) === '/' ? '/' : '';\n    if (tags[0] === 'xmlns') {\n      return '';\n    }\n    if (tags.length === 2) {\n      tagname = prefix + tags[1];\n    }\n  }\n  return tagname;\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])([\\\\s\\\\S]*?)\\\\3)?', 'gm');\n\nfunction buildAttributesMap(attrStr, jPath, tagName) {\n  if (!this.options.ignoreAttributes && typeof attrStr === 'string') {\n    // attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n    //attrStr = attrStr || attrStr.trim();\n\n    const matches = util.getAllMatches(attrStr, attrsRegx);\n    const len = matches.length; //don't make it inline\n    const attrs = {};\n    for (let i = 0; i < len; i++) {\n      const attrName = this.resolveNameSpace(matches[i][1]);\n      let oldVal = matches[i][4];\n      let aName = this.options.attributeNamePrefix + attrName;\n      if (attrName.length) {\n        if (this.options.transformAttributeName) {\n          aName = this.options.transformAttributeName(aName);\n        }\n        if(aName === \"__proto__\") aName  = \"#__proto__\";\n        if (oldVal !== undefined) {\n          if (this.options.trimValues) {\n            oldVal = oldVal.trim();\n          }\n          oldVal = this.replaceEntitiesValue(oldVal);\n          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);\n          if(newVal === null || newVal === undefined){\n            //don't parse\n            attrs[aName] = oldVal;\n          }else if(typeof newVal !== typeof oldVal || newVal !== oldVal){\n            //overwrite\n            attrs[aName] = newVal;\n          }else{\n            //parse\n            attrs[aName] = parseValue(\n              oldVal,\n              this.options.parseAttributeValue,\n              this.options.numberParseOptions\n            );\n          }\n        } else if (this.options.allowBooleanAttributes) {\n          attrs[aName] = true;\n        }\n      }\n    }\n    if (!Object.keys(attrs).length) {\n      return;\n    }\n    if (this.options.attributesGroupName) {\n      const attrCollection = {};\n      attrCollection[this.options.attributesGroupName] = attrs;\n      return attrCollection;\n    }\n    return attrs\n  }\n}\n\nconst parseXml = function(xmlData) {\n  xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\"); //TODO: remove this line\n  const xmlObj = new xmlNode('!xml');\n  let currentNode = xmlObj;\n  let textData = \"\";\n  let jPath = \"\";\n  for(let i=0; i< xmlData.length; i++){//for each char in XML data\n    const ch = xmlData[i];\n    if(ch === '<'){\n      // const nextIndex = i+1;\n      // const _2ndChar = xmlData[nextIndex];\n      if( xmlData[i+1] === '/') {//Closing Tag\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\")\n        let tagName = xmlData.substring(i+2,closeIndex).trim();\n\n        if(this.options.removeNSPrefix){\n          const colonIndex = tagName.indexOf(\":\");\n          if(colonIndex !== -1){\n            tagName = tagName.substr(colonIndex+1);\n          }\n        }\n\n        if(this.options.transformTagName) {\n          tagName = this.options.transformTagName(tagName);\n        }\n\n        if(currentNode){\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        }\n\n        //check if last tag of nested tag was unpaired tag\n        const lastTagName = jPath.substring(jPath.lastIndexOf(\".\")+1);\n        if(tagName && this.options.unpairedTags.indexOf(tagName) !== -1 ){\n          throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);\n        }\n        let propIndex = 0\n        if(lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1 ){\n          propIndex = jPath.lastIndexOf('.', jPath.lastIndexOf('.')-1)\n          this.tagsNodeStack.pop();\n        }else{\n          propIndex = jPath.lastIndexOf(\".\");\n        }\n        jPath = jPath.substring(0, propIndex);\n\n        currentNode = this.tagsNodeStack.pop();//avoid recursion, set the parent tag scope\n        textData = \"\";\n        i = closeIndex;\n      } else if( xmlData[i+1] === '?') {\n\n        let tagData = readTagExp(xmlData,i, false, \"?>\");\n        if(!tagData) throw new Error(\"Pi Tag is not closed.\");\n\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        if( (this.options.ignoreDeclaration && tagData.tagName === \"?xml\") || this.options.ignorePiTags){\n\n        }else{\n  \n          const childNode = new xmlNode(tagData.tagName);\n          childNode.add(this.options.textNodeName, \"\");\n          \n          if(tagData.tagName !== tagData.tagExp && tagData.attrExpPresent){\n            childNode[\":@\"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);\n          }\n          this.addChild(currentNode, childNode, jPath)\n\n        }\n\n\n        i = tagData.closeIndex + 1;\n      } else if(xmlData.substr(i + 1, 3) === '!--') {\n        const endIndex = findClosingIndex(xmlData, \"-->\", i+4, \"Comment is not closed.\")\n        if(this.options.commentPropName){\n          const comment = xmlData.substring(i + 4, endIndex - 2);\n\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n\n          currentNode.add(this.options.commentPropName, [ { [this.options.textNodeName] : comment } ]);\n        }\n        i = endIndex;\n      } else if( xmlData.substr(i + 1, 2) === '!D') {\n        const result = readDocType(xmlData, i);\n        this.docTypeEntities = result.entities;\n        i = result.i;\n      }else if(xmlData.substr(i + 1, 2) === '![') {\n        const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2;\n        const tagExp = xmlData.substring(i + 9,closeIndex);\n\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n\n        //cdata should be set even if it is 0 length string\n        if(this.options.cdataPropName){\n          // let val = this.parseTextData(tagExp, this.options.cdataPropName, jPath + \".\" + this.options.cdataPropName, true, false, true);\n          // if(!val) val = \"\";\n          currentNode.add(this.options.cdataPropName, [ { [this.options.textNodeName] : tagExp } ]);\n        }else{\n          let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);\n          if(val == undefined) val = \"\";\n          currentNode.add(this.options.textNodeName, val);\n        }\n        \n        i = closeIndex + 2;\n      }else {//Opening tag\n        let result = readTagExp(xmlData,i, this.options.removeNSPrefix);\n        let tagName= result.tagName;\n        const rawTagName = result.rawTagName;\n        let tagExp = result.tagExp;\n        let attrExpPresent = result.attrExpPresent;\n        let closeIndex = result.closeIndex;\n\n        if (this.options.transformTagName) {\n          tagName = this.options.transformTagName(tagName);\n        }\n        \n        //save text as child node\n        if (currentNode && textData) {\n          if(currentNode.tagname !== '!xml'){\n            //when nested tag is found\n            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);\n          }\n        }\n\n        //check if last tag was unpaired tag\n        const lastTag = currentNode;\n        if(lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1 ){\n          currentNode = this.tagsNodeStack.pop();\n          jPath = jPath.substring(0, jPath.lastIndexOf(\".\"));\n        }\n        if(tagName !== xmlObj.tagname){\n          jPath += jPath ? \".\" + tagName : tagName;\n        }\n        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {\n          let tagContent = \"\";\n          //self-closing tag\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){\n            i = result.closeIndex;\n          }\n          //unpaired tag\n          else if(this.options.unpairedTags.indexOf(tagName) !== -1){\n            i = result.closeIndex;\n          }\n          //normal tag\n          else{\n            //read until closing tag is found\n            const result = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);\n            if(!result) throw new Error(`Unexpected end of ${rawTagName}`);\n            i = result.i;\n            tagContent = result.tagContent;\n          }\n\n          const childNode = new xmlNode(tagName);\n          if(tagName !== tagExp && attrExpPresent){\n            childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n          }\n          if(tagContent) {\n            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);\n          }\n          \n          jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n          childNode.add(this.options.textNodeName, tagContent);\n          \n          this.addChild(currentNode, childNode, jPath)\n        }else{\n  //selfClosing tag\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){\n            if(tagName[tagName.length - 1] === \"/\"){ //remove trailing '/'\n              tagName = tagName.substr(0, tagName.length - 1);\n              jPath = jPath.substr(0, jPath.length - 1);\n              tagExp = tagName;\n            }else{\n              tagExp = tagExp.substr(0, tagExp.length - 1);\n            }\n            \n            if(this.options.transformTagName) {\n              tagName = this.options.transformTagName(tagName);\n            }\n\n            const childNode = new xmlNode(tagName);\n            if(tagName !== tagExp && attrExpPresent){\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n            }\n            this.addChild(currentNode, childNode, jPath)\n            jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n          }\n    //opening tag\n          else{\n            const childNode = new xmlNode( tagName);\n            this.tagsNodeStack.push(currentNode);\n            \n            if(tagName !== tagExp && attrExpPresent){\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n            }\n            this.addChild(currentNode, childNode, jPath)\n            currentNode = childNode;\n          }\n          textData = \"\";\n          i = closeIndex;\n        }\n      }\n    }else{\n      textData += xmlData[i];\n    }\n  }\n  return xmlObj.child;\n}\n\nfunction addChild(currentNode, childNode, jPath){\n  const result = this.options.updateTag(childNode.tagname, jPath, childNode[\":@\"])\n  if(result === false){\n  }else if(typeof result === \"string\"){\n    childNode.tagname = result\n    currentNode.addChild(childNode);\n  }else{\n    currentNode.addChild(childNode);\n  }\n}\n\nconst replaceEntitiesValue = function(val){\n\n  if(this.options.processEntities){\n    for(let entityName in this.docTypeEntities){\n      const entity = this.docTypeEntities[entityName];\n      val = val.replace( entity.regx, entity.val);\n    }\n    for(let entityName in this.lastEntities){\n      const entity = this.lastEntities[entityName];\n      val = val.replace( entity.regex, entity.val);\n    }\n    if(this.options.htmlEntities){\n      for(let entityName in this.htmlEntities){\n        const entity = this.htmlEntities[entityName];\n        val = val.replace( entity.regex, entity.val);\n      }\n    }\n    val = val.replace( this.ampEntity.regex, this.ampEntity.val);\n  }\n  return val;\n}\nfunction saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {\n  if (textData) { //store previously collected data as textNode\n    if(isLeafNode === undefined) isLeafNode = Object.keys(currentNode.child).length === 0\n    \n    textData = this.parseTextData(textData,\n      currentNode.tagname,\n      jPath,\n      false,\n      currentNode[\":@\"] ? Object.keys(currentNode[\":@\"]).length !== 0 : false,\n      isLeafNode);\n\n    if (textData !== undefined && textData !== \"\")\n      currentNode.add(this.options.textNodeName, textData);\n    textData = \"\";\n  }\n  return textData;\n}\n\n//TODO: use jPath to simplify the logic\n/**\n * \n * @param {string[]} stopNodes \n * @param {string} jPath\n * @param {string} currentTagName \n */\nfunction isItStopNode(stopNodes, jPath, currentTagName){\n  const allNodesExp = \"*.\" + currentTagName;\n  for (const stopNodePath in stopNodes) {\n    const stopNodeExp = stopNodes[stopNodePath];\n    if( allNodesExp === stopNodeExp || jPath === stopNodeExp  ) return true;\n  }\n  return false;\n}\n\n/**\n * Returns the tag Expression and where it is ending handling single-double quotes situation\n * @param {string} xmlData \n * @param {number} i starting index\n * @returns \n */\nfunction tagExpWithClosingIndex(xmlData, i, closingChar = \">\"){\n  let attrBoundary;\n  let tagExp = \"\";\n  for (let index = i; index < xmlData.length; index++) {\n    let ch = xmlData[index];\n    if (attrBoundary) {\n        if (ch === attrBoundary) attrBoundary = \"\";//reset\n    } else if (ch === '\"' || ch === \"'\") {\n        attrBoundary = ch;\n    } else if (ch === closingChar[0]) {\n      if(closingChar[1]){\n        if(xmlData[index + 1] === closingChar[1]){\n          return {\n            data: tagExp,\n            index: index\n          }\n        }\n      }else{\n        return {\n          data: tagExp,\n          index: index\n        }\n      }\n    } else if (ch === '\\t') {\n      ch = \" \"\n    }\n    tagExp += ch;\n  }\n}\n\nfunction findClosingIndex(xmlData, str, i, errMsg){\n  const closingIndex = xmlData.indexOf(str, i);\n  if(closingIndex === -1){\n    throw new Error(errMsg)\n  }else{\n    return closingIndex + str.length - 1;\n  }\n}\n\nfunction readTagExp(xmlData,i, removeNSPrefix, closingChar = \">\"){\n  const result = tagExpWithClosingIndex(xmlData, i+1, closingChar);\n  if(!result) return;\n  let tagExp = result.data;\n  const closeIndex = result.index;\n  const separatorIndex = tagExp.search(/\\s/);\n  let tagName = tagExp;\n  let attrExpPresent = true;\n  if(separatorIndex !== -1){//separate tag name and attributes expression\n    tagName = tagExp.substring(0, separatorIndex);\n    tagExp = tagExp.substring(separatorIndex + 1).trimStart();\n  }\n\n  const rawTagName = tagName;\n  if(removeNSPrefix){\n    const colonIndex = tagName.indexOf(\":\");\n    if(colonIndex !== -1){\n      tagName = tagName.substr(colonIndex+1);\n      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);\n    }\n  }\n\n  return {\n    tagName: tagName,\n    tagExp: tagExp,\n    closeIndex: closeIndex,\n    attrExpPresent: attrExpPresent,\n    rawTagName: rawTagName,\n  }\n}\n/**\n * find paired tag for a stop node\n * @param {string} xmlData \n * @param {string} tagName \n * @param {number} i \n */\nfunction readStopNodeData(xmlData, tagName, i){\n  const startIndex = i;\n  // Starting at 1 since we already have an open tag\n  let openTagCount = 1;\n\n  for (; i < xmlData.length; i++) {\n    if( xmlData[i] === \"<\"){ \n      if (xmlData[i+1] === \"/\") {//close tag\n          const closeIndex = findClosingIndex(xmlData, \">\", i, `${tagName} is not closed`);\n          let closeTagName = xmlData.substring(i+2,closeIndex).trim();\n          if(closeTagName === tagName){\n            openTagCount--;\n            if (openTagCount === 0) {\n              return {\n                tagContent: xmlData.substring(startIndex, i),\n                i : closeIndex\n              }\n            }\n          }\n          i=closeIndex;\n        } else if(xmlData[i+1] === '?') { \n          const closeIndex = findClosingIndex(xmlData, \"?>\", i+1, \"StopNode is not closed.\")\n          i=closeIndex;\n        } else if(xmlData.substr(i + 1, 3) === '!--') { \n          const closeIndex = findClosingIndex(xmlData, \"-->\", i+3, \"StopNode is not closed.\")\n          i=closeIndex;\n        } else if(xmlData.substr(i + 1, 2) === '![') { \n          const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"StopNode is not closed.\") - 2;\n          i=closeIndex;\n        } else {\n          const tagData = readTagExp(xmlData, i, '>')\n\n          if (tagData) {\n            const openTagName = tagData && tagData.tagName;\n            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length-1] !== \"/\") {\n              openTagCount++;\n            }\n            i=tagData.closeIndex;\n          }\n        }\n      }\n  }//end for loop\n}\n\nfunction parseValue(val, shouldParse, options) {\n  if (shouldParse && typeof val === 'string') {\n    //console.log(options)\n    const newval = val.trim();\n    if(newval === 'true' ) return true;\n    else if(newval === 'false' ) return false;\n    else return toNumber(val, options);\n  } else {\n    if (util.isExist(val)) {\n      return val;\n    } else {\n      return '';\n    }\n  }\n}\n\n\nmodule.exports = OrderedObjParser;\n","const { buildOptions} = require(\"./OptionsBuilder\");\nconst OrderedObjParser = require(\"./OrderedObjParser\");\nconst { prettify} = require(\"./node2json\");\nconst validator = require('../validator');\n\nclass XMLParser{\n    \n    constructor(options){\n        this.externalEntities = {};\n        this.options = buildOptions(options);\n        \n    }\n    /**\n     * Parse XML dats to JS object \n     * @param {string|Buffer} xmlData \n     * @param {boolean|Object} validationOption \n     */\n    parse(xmlData,validationOption){\n        if(typeof xmlData === \"string\"){\n        }else if( xmlData.toString){\n            xmlData = xmlData.toString();\n        }else{\n            throw new Error(\"XML data is accepted in String or Bytes[] form.\")\n        }\n        if( validationOption){\n            if(validationOption === true) validationOption = {}; //validate with default options\n            \n            const result = validator.validate(xmlData, validationOption);\n            if (result !== true) {\n              throw Error( `${result.err.msg}:${result.err.line}:${result.err.col}` )\n            }\n          }\n        const orderedObjParser = new OrderedObjParser(this.options);\n        orderedObjParser.addExternalEntities(this.externalEntities);\n        const orderedResult = orderedObjParser.parseXml(xmlData);\n        if(this.options.preserveOrder || orderedResult === undefined) return orderedResult;\n        else return prettify(orderedResult, this.options);\n    }\n\n    /**\n     * Add Entity which is not by default supported by this library\n     * @param {string} key \n     * @param {string} value \n     */\n    addEntity(key, value){\n        if(value.indexOf(\"&\") !== -1){\n            throw new Error(\"Entity value can't have '&'\")\n        }else if(key.indexOf(\"&\") !== -1 || key.indexOf(\";\") !== -1){\n            throw new Error(\"An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'\")\n        }else if(value === \"&\"){\n            throw new Error(\"An entity with value '&' is not permitted\");\n        }else{\n            this.externalEntities[key] = value;\n        }\n    }\n}\n\nmodule.exports = XMLParser;","'use strict';\n\n/**\n * \n * @param {array} node \n * @param {any} options \n * @returns \n */\nfunction prettify(node, options){\n  return compress( node, options);\n}\n\n/**\n * \n * @param {array} arr \n * @param {object} options \n * @param {string} jPath \n * @returns object\n */\nfunction compress(arr, options, jPath){\n  let text;\n  const compressedObj = {};\n  for (let i = 0; i < arr.length; i++) {\n    const tagObj = arr[i];\n    const property = propName(tagObj);\n    let newJpath = \"\";\n    if(jPath === undefined) newJpath = property;\n    else newJpath = jPath + \".\" + property;\n\n    if(property === options.textNodeName){\n      if(text === undefined) text = tagObj[property];\n      else text += \"\" + tagObj[property];\n    }else if(property === undefined){\n      continue;\n    }else if(tagObj[property]){\n      \n      let val = compress(tagObj[property], options, newJpath);\n      const isLeaf = isLeafTag(val, options);\n\n      if(tagObj[\":@\"]){\n        assignAttributes( val, tagObj[\":@\"], newJpath, options);\n      }else if(Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode){\n        val = val[options.textNodeName];\n      }else if(Object.keys(val).length === 0){\n        if(options.alwaysCreateTextNode) val[options.textNodeName] = \"\";\n        else val = \"\";\n      }\n\n      if(compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {\n        if(!Array.isArray(compressedObj[property])) {\n            compressedObj[property] = [ compressedObj[property] ];\n        }\n        compressedObj[property].push(val);\n      }else{\n        //TODO: if a node is not an array, then check if it should be an array\n        //also determine if it is a leaf node\n        if (options.isArray(property, newJpath, isLeaf )) {\n          compressedObj[property] = [val];\n        }else{\n          compressedObj[property] = val;\n        }\n      }\n    }\n    \n  }\n  // if(text && text.length > 0) compressedObj[options.textNodeName] = text;\n  if(typeof text === \"string\"){\n    if(text.length > 0) compressedObj[options.textNodeName] = text;\n  }else if(text !== undefined) compressedObj[options.textNodeName] = text;\n  return compressedObj;\n}\n\nfunction propName(obj){\n  const keys = Object.keys(obj);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if(key !== \":@\") return key;\n  }\n}\n\nfunction assignAttributes(obj, attrMap, jpath, options){\n  if (attrMap) {\n    const keys = Object.keys(attrMap);\n    const len = keys.length; //don't make it inline\n    for (let i = 0; i < len; i++) {\n      const atrrName = keys[i];\n      if (options.isArray(atrrName, jpath + \".\" + atrrName, true, true)) {\n        obj[atrrName] = [ attrMap[atrrName] ];\n      } else {\n        obj[atrrName] = attrMap[atrrName];\n      }\n    }\n  }\n}\n\nfunction isLeafTag(obj, options){\n  const { textNodeName } = options;\n  const propCount = Object.keys(obj).length;\n  \n  if (propCount === 0) {\n    return true;\n  }\n\n  if (\n    propCount === 1 &&\n    (obj[textNodeName] || typeof obj[textNodeName] === \"boolean\" || obj[textNodeName] === 0)\n  ) {\n    return true;\n  }\n\n  return false;\n}\nexports.prettify = prettify;\n","'use strict';\n\nclass XmlNode{\n  constructor(tagname) {\n    this.tagname = tagname;\n    this.child = []; //nested tags, text, cdata, comments in order\n    this[\":@\"] = {}; //attributes map\n  }\n  add(key,val){\n    // this.child.push( {name : key, val: val, isCdata: isCdata });\n    if(key === \"__proto__\") key = \"#__proto__\";\n    this.child.push( {[key]: val });\n  }\n  addChild(node) {\n    if(node.tagname === \"__proto__\") node.tagname = \"#__proto__\";\n    if(node[\":@\"] && Object.keys(node[\":@\"]).length > 0){\n      this.child.push( { [node.tagname]: node.child, [\":@\"]: node[\":@\"] });\n    }else{\n      this.child.push( { [node.tagname]: node.child });\n    }\n  };\n};\n\n\nmodule.exports = XmlNode;","'use strict';\nconst {XMLParser, XMLValidator} = require('fast-xml-parser');\n\nconst isSvg = input => {\n\tif (input === undefined || input === null) {\n\t\treturn false;\n\t}\n\n\tinput = input.toString().trim();\n\n\tif (input.length === 0) {\n\t\treturn false;\n\t}\n\n\t// Has to be `!==` as it can also return an object with error info.\n\tif (XMLValidator.validate(input) !== true) {\n\t\treturn false;\n\t}\n\n\tlet jsonObject;\n\tconst parser = new XMLParser();\n\n\ttry {\n\t\tjsonObject = parser.parse(input);\n\t} catch (_) {\n\t\treturn false;\n\t}\n\n\tif (!jsonObject) {\n\t\treturn false;\n\t}\n\n\tif (!('svg' in jsonObject)) {\n\t\treturn false;\n\t}\n\n\treturn true;\n};\n\nmodule.exports = isSvg;\n// TODO: Remove this for the next major release\nmodule.exports.default = isSvg;\n","const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;\nconst numRegex = /^([\\-\\+])?(0*)(\\.[0-9]+([eE]\\-?[0-9]+)?|[0-9]+(\\.[0-9]+([eE]\\-?[0-9]+)?)?)$/;\n// const octRegex = /0x[a-z0-9]+/;\n// const binRegex = /0x[a-z0-9]+/;\n\n\n//polyfill\nif (!Number.parseInt && window.parseInt) {\n    Number.parseInt = window.parseInt;\n}\nif (!Number.parseFloat && window.parseFloat) {\n    Number.parseFloat = window.parseFloat;\n}\n\n  \nconst consider = {\n    hex :  true,\n    leadingZeros: true,\n    decimalPoint: \"\\.\",\n    eNotation: true\n    //skipLike: /regex/\n};\n\nfunction toNumber(str, options = {}){\n    // const options = Object.assign({}, consider);\n    // if(opt.leadingZeros === false){\n    //     options.leadingZeros = false;\n    // }else if(opt.hex === false){\n    //     options.hex = false;\n    // }\n\n    options = Object.assign({}, consider, options );\n    if(!str || typeof str !== \"string\" ) return str;\n    \n    let trimmedStr  = str.trim();\n    // if(trimmedStr === \"0.0\") return 0;\n    // else if(trimmedStr === \"+0.0\") return 0;\n    // else if(trimmedStr === \"-0.0\") return -0;\n\n    if(options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;\n    else if (options.hex && hexRegex.test(trimmedStr)) {\n        return Number.parseInt(trimmedStr, 16);\n    // } else if (options.parseOct && octRegex.test(str)) {\n    //     return Number.parseInt(val, 8);\n    // }else if (options.parseBin && binRegex.test(str)) {\n    //     return Number.parseInt(val, 2);\n    }else{\n        //separate negative sign, leading zeros, and rest number\n        const match = numRegex.exec(trimmedStr);\n        if(match){\n            const sign = match[1];\n            const leadingZeros = match[2];\n            let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros\n            //trim ending zeros for floating number\n            \n            const eNotation = match[4] || match[6];\n            if(!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== \".\") return str; //-0123\n            else if(!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== \".\") return str; //0123\n            else{//no leading zeros or leading zeros are allowed\n                const num = Number(trimmedStr);\n                const numStr = \"\" + num;\n                if(numStr.search(/[eE]/) !== -1){ //given number is long and parsed to eNotation\n                    if(options.eNotation) return num;\n                    else return str;\n                }else if(eNotation){ //given number has enotation\n                    if(options.eNotation) return num;\n                    else return str;\n                }else if(trimmedStr.indexOf(\".\") !== -1){ //floating number\n                    // const decimalPart = match[5].substr(1);\n                    // const intPart = trimmedStr.substr(0,trimmedStr.indexOf(\".\"));\n\n                    \n                    // const p = numStr.indexOf(\".\");\n                    // const givenIntPart = numStr.substr(0,p);\n                    // const givenDecPart = numStr.substr(p+1);\n                    if(numStr === \"0\" && (numTrimmedByZeros === \"\") ) return num; //0.0\n                    else if(numStr === numTrimmedByZeros) return num; //0.456. 0.79000\n                    else if( sign && numStr === \"-\"+numTrimmedByZeros) return num;\n                    else return str;\n                }\n                \n                if(leadingZeros){\n                    // if(numTrimmedByZeros === numStr){\n                    //     if(options.leadingZeros) return num;\n                    //     else return str;\n                    // }else return str;\n                    if(numTrimmedByZeros === numStr) return num;\n                    else if(sign+numTrimmedByZeros === numStr) return num;\n                    else return str;\n                }\n\n                if(trimmedStr === numStr) return num;\n                else if(trimmedStr === sign+numStr) return num;\n                // else{\n                //     //number with +/- sign\n                //     trimmedStr.test(/[-+][0-9]);\n\n                // }\n                return str;\n            }\n            // else if(!eNotation && trimmedStr && trimmedStr !== Number(trimmedStr) ) return str;\n            \n        }else{ //non-numeric string\n            return str;\n        }\n    }\n}\n\n/**\n * \n * @param {string} numStr without leading zeros\n * @returns \n */\nfunction trimZeros(numStr){\n    if(numStr && numStr.indexOf(\".\") !== -1){//float\n        numStr = numStr.replace(/0+$/, \"\"); //remove ending zeros\n        if(numStr === \".\")  numStr = \"0\";\n        else if(numStr[0] === \".\")  numStr = \"0\"+numStr;\n        else if(numStr[numStr.length-1] === \".\")  numStr = numStr.substr(0,numStr.length-1);\n        return numStr;\n    }\n    return numStr;\n}\nmodule.exports = toNumber\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import type { OnRpcRequestHandler } from '@metamask/snaps-sdk';\nimport { panel, text } from '@metamask/snaps-sdk';\n\n/**\n * Handle incoming JSON-RPC requests, sent through `wallet_invokeSnap`.\n *\n * @param args - The request handler args as object.\n * @param args.origin - The origin of the request, e.g., the website that\n * invoked the snap.\n * @param args.request - A validated JSON-RPC request object.\n * @returns The result of `snap_dialog`.\n * @throws If the request method is not valid for this snap.\n */\nexport const onRpcRequest: OnRpcRequestHandler = async ({\n  origin,\n  request,\n}) => {\n  switch (request.method) {\n    case 'hello':\n      return snap.request({\n        method: 'snap_dialog',\n        params: {\n          type: 'confirmation',\n          content: panel([\n            text(`Hello, **${origin}**!`),\n            text('This custom confirmation is just for display purposes.'),\n            text(\n              'But you can edit the snap source code to make it do something, if you want to!',\n            ),\n          ]),\n        },\n      });\n    default:\n      throw new Error('Method not found.');\n  }\n};\n"],"names":["chunk_H4YFDLB7_isObject","value","Boolean","Array","isArray","hasProperty","objectToCheck","name","Object","hasOwnProperty","call","JsonSize2","JsonSize","StructError","TypeError","constructor","failure","failures","cached","message","explanation","rest","path","msg","length","join","cause","assign","dist_isObject","x","print","toString","JSON","stringify","toFailure","result","context","struct","branch","type","refinement","key","toFailures","Symbol","iterator","r","run","options","coerce","mask","ctx","coercer","schema","undefined","status","validator","k","v","s","entries","ts","t","Map","set","Set","add","refiner","Struct","props","assert","create","is","dist_is","validate","tuples","tuple","input","done","next","shiftIterator","dist_assign","Structs","isType","schemas","map","object","dist_define","lazy","fn","array","Element","i","slice","dist_boolean","literal","constant","description","never","number","isNaN","knowns","keys","Never","unknowns","delete","optional","record","Key","Value","string","union","S","error","coerced","first","push","unknown","condition","refine","getErrorMessageWithoutTrailingPeriod","isErrorWithMessage","String","getErrorMessage","replace","getError","ErrorWrapper","prototype","AssertionError","Error","code","chunk_74DGVJVE_assertStruct","errorPrefix","chunk_6C35XQOF_object","hasOptional","field","exactOptional","UnsafeJsonStruct","Number","isFinite","JsonStruct","parse","propKey","propValue","isValidJson","getSafeJson","JsonRpcVersionStruct","JsonRpcIdStruct","nullable","JsonRpcErrorStruct","isInteger","data","stack","JsonRpcParamsStruct","id","jsonrpc","method","params","JsonRpcSuccessStruct","JsonRpcFailureStruct","SNAP_ERROR_CODE","SNAP_ERROR_MESSAGE","errors_getErrorMessage","getErrorStack","getErrorData","structs_literal","structs_union","head","tail","enumValue","_class_extract_field_descriptor","receiver","privateMap","action","has","get","_class_private_field_get","descriptor","_class_apply_descriptor_get","_class_private_field_init","obj","privateCollection","_check_private_redeclaration","_class_private_field_set","writable","_class_apply_descriptor_set","SeverityLevel","DialogType","AuxiliaryFileEncoding","ManageStateOperation","NotificationType","NodeType","_code","WeakMap","_message","_data","_stack","SnapError","toJSON","serialize","getErrorCode","createBuilder","args","proto","getPrototypeOf","_","isPlainObject","node","reduce","partialNode","index","NodeStruct","LiteralStruct","AddressStruct","Address","regexp","test","source","pattern","address","CopyableStruct","Copyable","sensitive","copyable","DividerStruct","Divider","divider","HeadingStruct","Heading","heading","ImageStruct","Image","is_svg_default","image_image","TextStruct","Text","markdown","text_text","RowVariant","RowComponentStruct","RowStruct","Row","variant","Default","Critical","Warning","label","row","SpinnerStruct","Spinner","spinner","ParentStruct","children","ComponentStruct","PanelStruct","Panel","panel","isComponent","assertIsComponent","__webpack_require__","XMLParser","XMLBuilder","module","exports","XMLValidator","nameStartChar","nameRegexp","regexName","RegExp","isExist","isEmptyObject","merge","target","a","arrayMode","len","getValue","isName","match","exec","getAllMatches","regex","matches","allmatches","startIndex","lastIndex","util","defaultOptions","allowBooleanAttributes","unpairedTags","isWhiteSpace","char","readPI","xmlData","start","tagname","substr","getErrorObject","getLineNumberForPosition","readCommentAndCDATA","angleBracketsCount","tags","tagFound","reachedRoot","err","tagStartPos","closingTag","tagName","trim","substring","readAttributeStr","attrStr","attrStrStart","isValid","validateAttributeString","line","tagClosed","otg","pop","openPos","col","indexOf","afterAmp","validateAmpersand","doubleQuote","singleQuote","startChar","validAttrStrRegxp","attrNames","getPositionFromMatch","attrName","validateAttrName","re","validateNumberAmpersand","count","lineNumber","lines","split","buildFromOrderedJs","attributeNamePrefix","attributesGroupName","textNodeName","ignoreAttributes","cdataPropName","format","indentBy","suppressEmptyNode","suppressUnpairedNode","suppressBooleanAttributes","tagValueProcessor","attributeValueProcessor","preserveOrder","commentPropName","entities","val","processEntities","stopNodes","oneListGroup","Builder","isAttribute","attrPrefixLen","processTextOrObjNode","indentate","tagEndChar","newLine","level","j2x","buildTextValNode","buildObjectNode","repeat","startsWith","build","jObj","arrayNodeName","Date","attr","buildAttrPairStr","newval","replaceEntitiesValue","arrLen","listTagVal","j","item","Ks","L","closeTag","tagEndExp","piClosingChar","textValue","entity","arrToStr","arr","jPath","indentation","xmlStr","isPreviousElementTag","tagObj","propName","newJPath","tagText","isStopNode","attStr","attr_to_str","tempInd","piTextNodeName","newIdentation","tagStart","tagValue","endsWith","includes","attrMap","attrVal","lastIndexOf","jArray","readEntityExp","entityName","isComment","isEntity","isElement","isAttlist","isNotation","validateEntityName","hasBody","comment","exp","regx","removeNSPrefix","parseTagValue","parseAttributeValue","trimValues","numberParseOptions","hex","leadingZeros","eNotation","alwaysCreateTextNode","htmlEntities","ignoreDeclaration","ignorePiTags","transformTagName","transformAttributeName","updateTag","attrs","buildOptions","xmlNode","readDocType","toNumber","addExternalEntities","externalEntities","entKeys","ent","lastEntities","parseTextData","dontTrim","hasAttributes","isLeafNode","escapeEntities","parseValue","resolveNameSpace","prefix","charAt","attrsRegx","buildAttributesMap","oldVal","aName","newVal","attrCollection","parseXml","xmlObj","currentNode","textData","closeIndex","findClosingIndex","colonIndex","saveTextToParentTag","lastTagName","propIndex","tagsNodeStack","tagData","readTagExp","childNode","tagExp","attrExpPresent","addChild","endIndex","this","docTypeEntities","rawTagName","lastTag","isItStopNode","tagContent","readStopNodeData","child","ampEntity","currentTagName","allNodesExp","stopNodePath","stopNodeExp","str","errMsg","closingIndex","closingChar","attrBoundary","ch","tagExpWithClosingIndex","separatorIndex","search","trimStart","openTagCount","shouldParse","OrderedObjParser","prettify","validationOption","orderedObjParser","orderedResult","addEntity","compress","text","compressedObj","property","newJpath","isLeaf","isLeafTag","assignAttributes","jpath","atrrName","propCount","isSvg","jsonObject","parser","hexRegex","numRegex","parseInt","window","parseFloat","consider","decimalPoint","trimmedStr","skipLike","sign","numTrimmedByZeros","numStr","trimZeros","num","__webpack_module_cache__","moduleId","cachedModule","__webpack_modules__","n","getter","__esModule","d","definition","o","defineProperty","enumerable","prop","toStringTag","onRpcRequest","async","origin","request","snap","content","_snapssdk"],"sourceRoot":""}